<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>CSDN大数据</title>
    <link>http://www.iwgc.cn/list/1933</link>
    <description>CSDN分享Hadoop、Spark、NoSQL/NewSQL、HBase、Impala、内存计算、流计算、机器学习和智能算法等相关大数据观点,提供云计算和大数据技术、平台、实践和产业信息等服务.</description>
    <item>
      <title>【SDCC讲师专访】专访百度架构师郑然：架构的本质是为了服务业务</title>
      <link>http://www.iwgc.cn/link/2625172</link>
      <description>&lt;p&gt;&lt;span&gt;2016年9月22日-23日，由CSDN重磅打造的SDCC&amp;nbsp;2016大数据技术&amp;amp;架构实战峰会（杭州站）将在杭州举行。大会前夕，百度网页搜索架构部架构师郑然接受了CSDN专访，谈及了对架构的理解、SOFA（Service&amp;nbsp;Oriented&amp;nbsp;Flyweight&amp;nbsp;Architecture）的前世今生，以及技术人提升之道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAujiaJv6TA783GOb2DYpVXos6cPjqVibhyBV4braibkib9A4OBKJ53X9qmia11eV3mLnvJPYfXhZBhDm3Bg/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;百度网页搜索架构部架构师&amp;nbsp;郑然&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;嘉宾介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;郑然于2009年加入百度网页搜索部，在百度网页搜索部工作的7年时间里，一直从事百度搜索引擎的架构研发工作，先后负责过百度搜索引擎的大规模索引构建工作，大数据离线平台架构工作。近几年来一直从事着大规模服务治理相关工作，包括支撑大规模服务变更的PaaS系统，保障百度搜索引擎99。995%可靠性的高可用架构和中间件，以及百度搜索引擎容量规划和评估等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;专访正文&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CSDN：请先和大家介绍下您和目前所从事的工作，以及关注哪些技术领域？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;郑然：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我自从2009年加入百度以来，一直在网页搜索部从事搜索引擎架构相关的工作。&amp;nbsp;从最开始的大规模分布式索引建库系统到离线泛建库大数据分析架构相关的工作。近几年一直从事大规模服务治理技术的研发工作，设计并实施了轻量级的接口化和组件化的微服务开发平台SOFA；带领团队对支撑百度搜索引擎海量服务部署和变更的PaaS平台——Eden进行了一系列重构和优化（日前在业内技术大会上分享过Eden，Slides参见：《Eden&amp;nbsp;–&amp;nbsp;百度搜索系统的PaaS架构设计和实践》）；现阶段，我们把服务治理拆分成效率提升，高可用架构和容量优化三个大方向，系统化的解决服务治理面临的问题，构建搜索引擎的私有云平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我个人对于高可用架构、云计算、容器和微服务、服务治理、DevOps等技术领域非常感兴趣，也希望和大家进一步交流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CSDN：：作为一名资深架构师，能否谈下您对架构的理解？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;郑然：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这个问题有点大，我理解架构的本质是为了业务服务的，解决不了业务问题的架构毫无用处。但是往往业务问题是复杂的，同时已有架构和系统都会或多或少的存在技术债务（我猜大多数情况下技术债务还不少）。所以我觉得对于一个架构师来说，选择正确的时间，使用正确的技术，选择解决哪些问题，最终能给业务带来什么价值，是需要经过深思熟虑的。一方面要能满足业务需求，解决业务问题，另一方面又要偿还技术债务，让系统向着理想目标前进，这其实需要很多折中和权衡，即使在架构设计过程中也往往是一个折中的过程。不过恰巧是这一点，让我觉得这正是吸引我一直从事架构相关工作的原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CSDN：有人觉得架构师是个很高大上的职业，您觉得作为一名架构师，需要具备哪些能力？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;郑然：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我一直工作在一线，从“硬件”和“软件”两方面谈：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;“硬件”方面我主要指技术能力&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;架构的设计要求具备很强的抽象能力。对于复杂系统，大到能设计整体架构，对于核心技术做出正确的技术选型和技术判断，小到能清楚的知道API的接口设计和实现逻辑，做到当团队只有一个人的时候，也能开发出来，区别就是时间长短而已。这要求架构师具备丰富的技术储备，需要在工作过程中不断总结和归纳，同时开阔技术视野，取长补短。这些都需要时间的积累，不是一日之功，&amp;nbsp;没有捷径可走。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;“软件”方面，涉及的点就比较多了，我觉得比较重要的就是规划能力、表达能力、技术领导能力和技术影响力。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: circle;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于规划能力，我们通俗的说叫”吃着碗里的，看着锅里的”。我们在做着当前工作的同时，必须不断思考未来是什么，大到系统的理想形态是什么，小到系统的最合理设计是什么等。这个未来不需要太长，我觉得半年到一年就可以了。我自己的体会是，如果有些地方我思考不清楚了，那就会让我寝食难安，如果想清楚了，心里会充满平静。除了思考清楚理想形态之外，还需要思考逐步达到理想形态的过程。因为理想形态往往不可能一蹴而就，这就要求我们心怀业务目标，在达成业务目标的情况下，逐步达成理想形态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;表达能力有些朋友可能觉得不是那么关键，其实不然。在职场中，需要沟通的地方很多，包括团队内部问题讨论，跨团队的需求沟通，跨部门的项目合作，向上级汇报工作，&amp;nbsp;给下级分配工作等等。即使同一个问题，面对不同的人，说法完全不同。这里有一个窍门，&amp;nbsp;就是一定要站在对方的角度，然后再想怎么说，往往可以起到事倍功半的效果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;技术领导能力是一个比较大的话题，我自己也讲不清楚。我的一点点体会是，以人为本。大家愿意和你一起工作，除了公司大环境之外，更多的是考虑这个方向的空间以及个人的成长。所以我给自己设置的一个隐性目标就是为大家发掘和创造更大的成长空间，让团队中的每个人都能获得足够的成长。&amp;nbsp;团队成长了也就能更好的为公司创造价值了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;技术影响力提升我觉得也是很重要的一个方面，你自身的影响力提升了，也可以吸引更多的人加入团队。提升技术影响力的途径有很多，比如公开演讲，写技术文章，组织部门内部的技术交流会和一些课程，发表论文和专利等。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CSDN：您在百度网页搜索部工作了7年，能够分享下近年来百度搜索引擎的挑战？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;郑然：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;百度搜索引擎其实一直在不断更新，只不过可能每天只提升一点点，影响一小部分query，大家感受不那么明显，是一个从量变到质变的过程。百度一直以“让人们最平等便捷的获取信息，找到所求”为使命，随着移动互联网的发展以及信息量的不断膨胀，用户找到信息的难度更大了。所以从2016年开始百度正在从多个维度全面打造“新搜索”，让搜索结果多样化全方位的满足用户请求，同时不断完善内容生态，促进优质内容在百度全平台的承载。这就意味着百度搜索引擎的算法复杂度和数据计算存储量的大幅提升，给搜索引擎的算法和架构带来了巨大的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CSDN：这次在SDCC&amp;nbsp;2016（杭州）架构峰会上，您主要分享SOFA（Service&amp;nbsp;Oriented&amp;nbsp;Flyweight&amp;nbsp;Architecture）这一轻量级的面向服务的开发框架，可否介绍下SOFA的前世今生？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;郑然：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;先澄清一下，&amp;nbsp;sofa-pbrpc和我要分享的SOFA是完全不同的。以我们的反作弊服务为例，反作弊服务需要根据网页的HTML计算和解析出上千个特征，然后在经过几百个策略，最后得出反作弊的结果。这上千个特征存在错综复杂的依赖关系，策略与策略之间也存在着严格的顺序要求。随着算法的越发复杂，有些特征或者策略的计算需要消耗的资源会越来越大，&amp;nbsp;这时候大家想到的办法一定是对服务进行拆分了。如果没有SOFA，这样的拆分过程相当于做一次重构的工作量，而且对反作弊效果来说是没有正向收益的，做算法的同学最不愿意做这种事情。所以能否灵活的进行拆分，就是提升研发效果的关键了。使用SOFA技术以后，修改几行配置就可以实现拆分了；另外反作弊服务中有些特征和策略的计算逻辑，可能其他服务或者产品线也同样需求，比如切词，提取title、content、anchor等，那么如果能非常方便的实现代码共享，也势必大幅提升研发效率。所以在这种情形下，我们设计和实现了SOFA这一接口化和组件化的开发平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在2013年SOFA完成的第一个版本中，我们已经实现了RPC的功能并且性能十分优异，考虑到当时距离SOFA成型还有相对较长的时间，同时部门内一些偏向基础架构的系统（比如百度开源的tera分布式表格系统）仅仅有RPC的需求，所以我们把SOFA中RPC的代码剥离出来，适配了protobuf，于是乎就有了sofa-pbrpc这个项目了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以说RPC只是SOFA的冰山一角，&amp;nbsp;我希望通过本次SDCC的分享，给大家揭秘整个SOFA平台。不过由于SOFA依赖了一些公司的库以及人力问题，还没有开源出来，但是我个人认为整个SOFA的设计思想还是非常先进的，所以决定在本次SDCC上为大家介绍SOFA，希望能给大家带来一点点启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CSDN：SOFA目前有哪些最佳实践？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;郑然：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;SOFA自身具备接口化和RPC的能力，所以适用于所有应用RPC的场合。同时得益于SOFA接口化和组件化的设计思想，更适合于构建带有复杂业务逻辑的服务模块。不知道大家有没有遇到过这样的场景，比如我想使用切词功能，于是我从公司的代码库中反复搜索，终于找到了代码路径。Checkout下来之后，首先阅读头文件，看过复杂的结构体声明和函数定义以后，准备写一个demo程序做实验。代码写完编译好之后，发现缺少切词词典，于是乎从公司的wiki上反复搜索，终于找到对应的接口RD，我们从一个FTP地址下载了切词词典。然后运行demo，词典加载失败，联系接口RD发现词典版本和代码版本不匹配，于是重新下载对应版本的切词词典，终于demo运行通过了。下一步当然是把切词的逻辑添加到线上的模块了。代码写完并且添加好编译依赖之后，发现编译不通过，原来切词库依赖的一个库和当前模块冲突了，打平之后发现当前开发的模块又编译不通过了……这时候如果运气好的话，经过反复实验，可以找到一个编译通过的版本;&amp;nbsp;运气不好的话，那只能修改相应的代码了，真是一如好闷深似海啊!&amp;nbsp;烧香拜佛之后，终于编译通过了，运行之后程序如果core了，这还算好的，如果运行之后得出的结果不对，&amp;nbsp;那才叫一个叫天天不应叫地地不灵呢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;遗憾的是，我们的搜索服务中存在很多这样的模块。我们的反作弊服务和页面解析服务都是包含复杂的特征提取和算法模块，这些模块随着算法复杂度的提升，需要的CPU和内存会不断提升。如果说编译依赖冲突的问题还可以通过一些艰苦卓绝的工作解决，那么资源需求达到一定程度之后，就必须进行服务拆分了。没有使用SOFA之前，这样的拆分是非常复杂的，不仅仅研发周期长，对服务的效果又起不到提升的作用研发过程需要反复的测试功能和效果的评估，给算法的研发同学带来的极大的痛苦。SOFA的接口化和组件化的设计思想，可以大大简化上述过程。组件的符号隔离机制，确保组件之间不同版本的库并存;&amp;nbsp;接口化和组件化的能力使得我们仅仅通过修改配置，就可以完成服务拆分工作;&amp;nbsp;而且不同的组件可以采用不同的编程语言，&amp;nbsp;进一步加速组件的研发效率。SOFA上线以后，&amp;nbsp;先后支持了公司包括网页搜索，自然语言处理，深度学习研究院，机器翻译等十几个的产品线，构建了上百个服务，使用SOFA的研发人员接近200人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CSDN：微服务目前受到广大互联网公司的热捧，您如何评价这一现象？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;郑然：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;可能很多朋友看到微服务带来的可扩展、松耦合、研发和迭代效率提升等优点，&amp;nbsp;都有蠢蠢欲动的感觉。微服务背后隐藏着一座冰山，我们看到的往往是浮出水面的华丽的部分，而水下作为微服务的底座，需要包含日志的汇总和分析、服务注册和发现、部署和升级、资源管理、CI/CD流水线、服务依赖关系管理、调用链跟踪框架、灰度发布、蓝绿部署、容量评估和规划等技术，如果公司对这些基础设施缺乏积累，那么引入微服务架构我觉得会是一场噩梦。当然这些基础设施的发展也很迅速，开源社区也非常活跃，大大降低了建设这些基础设施的门槛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CSDN：您作为技术人员，擅长太多，包括：流式索引构建系统&amp;amp;离线计算平台架构&amp;amp;PaaS&amp;amp;服务治理&amp;amp;高可用架构&amp;amp;DevOps等，可否分享下您学习新知识或技能的方法？以及在日常生活中你是通过哪些方式来提升个人技能的？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;郑然：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对于我来说，我特别享受学习的过程。我一直坚持每天7:30到公司，吃过早饭之后读一个小时的早报。早报的内容大部分是来自各个微信公众号和自媒体，把其中认为好的文章记录下来，这样组织了一个《分布式技术一周技术动态》的小专栏，每周为大家推送。&amp;nbsp;这个小专栏持续了一年半了，总共推送了上千篇技术文章，我个人的知识面也得到了很大的扩展。我也一直坚持组织团队和部门的技术分享会，我一个人的力量毕竟是有限的，我希望所有人都养成学习的习惯，当然我也可以从大家的分享中更快速的获取知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过如果需要系统的学习，还是需要看书的，公司提供了图书馆制度，每个人每个季度都有一定的额度购买图书。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我的日常工作主要包括系统设计方案评审，项目过程中疑难问题的解决，需求和方案的讨论，&amp;nbsp;code&amp;nbsp;review。我喜欢编码，如果一段时间不写代码，就感觉心里不踏实，我的代码量在部门内排名还是比较靠前的。除此之外，我还需要给自己预留学习和思考的时间，这里的学习不是像读早报那样泛泛的学习，需要一定的系统学习，比如读一本书，学习一个开源或者公司内部的系统，学习设计方案等。思考的时间也特别重要，我需要保证我做出的技术决策大部分是对的，我需要保证整体技术方向不会出现偏差，我需要保证每个同学都有足够的成长空间，&amp;nbsp;这些都需要深入思考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;</description>
      <pubDate>Fri, 09 Sep 2016 16:48:18 +0800</pubDate>
    </item>
    <item>
      <title>诚荐丨参加SDCC 2016大数据&amp;amp;架构峰会·杭州站的七大理由</title>
      <link>http://www.iwgc.cn/link/2625173</link>
      <description>&lt;p&gt;&lt;span&gt;自2016年8月25日，我们上线了SDCC 2016大数据&amp;amp;架构峰会·杭州站的官网以来，我们发布了多篇的讲师专访，会议日程等稿件，想必很多人都已经知道了此次杭州峰会，为了让报名者以及感兴趣者深入了解次此次峰会，我们特别整理了以往所有的信息和资料，以及近期会放出的大招。&lt;strong&gt;为你总结，参加SDCC 2016大数据&amp;amp;架构峰会·杭州站的七大理由。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;一&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;国内一线互联网公司齐聚，共话精彩话题&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本次大会邀请的演讲嘉宾，他们均来自科技圈知名的互联网公司：百度、腾讯、蚂蚁金服、网易、京东、苏宁、小米、唯品会、美团点评、唯品会、蘑菇街、游族、饿了么、有赞、Echo、In公司、1药网等；议题全面，聚焦当下热门话题，精彩纷呈：海量数据下的应用监控系统建设、异常检测的算法和实现、大数据基础架构实践、数据平台的构建及其应用、深度学习、机器学习算法、个性化推荐、数据服务的架构演进，以及高可用/高并发/高性能系统架构设计、电商核心交易系统架构、分布式架构、应用系统架构、数据库访问层的架构设计、Hybrid框架、云服务架构、微服务等议题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术荟萃，热辣共享，饕餮盛宴，引爆杭州大数据技术圈；和一线资深架构师一起，深度交流和沉浸式学习，全面提升你的技术实力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;二&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;实力大腕云集，机不可失&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SDCC 2016·杭州站的大数据和架构峰会上，你将会看到这些老司机：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;大数据实战峰会（9月22日）&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;陈 超 七牛云技术总监（出品人&amp;amp;主持人）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;姚 捷 唯品会平台架构部高级架构师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;黄大鹏 蘑菇街数据平台部实时计算经理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;姚仁捷 游族网络运维开发经理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;倪增光 饿了么数据运营部技术经理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;洪 斌 有赞数据技术团队leader&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;陈 健 Echo数据组·算法工程师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;张 毅 In架构师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;李呈祥 万达金融网络技术中心大数据技术专家&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;互联网应用架构峰会（9月23日）&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;张立刚 1号店架构部技术总监（出品人&amp;amp;主持人）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;郑 然 百度网页搜索架构部架构师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;司孝波 苏宁云商中台研发中心技术副总监&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;张荣华 蚂蚁金服智能BI平台技术架构师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;杨 超 京东商城架构师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尧飘海 网易云云计算架构师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;秦曲波 1药网B2C技术部技术总监&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;翟 伟 腾讯SNG增值产品部高级工程师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;朱 浩 美团点评基础架构存储团队负责人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;张广平 唯品会应用架构负责人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们不仅在讲师层面有内部沟通会，而且现场会设置专门的提问环节、现场微信群优先获得会议课件、讲师结束后微信群进行答疑……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;三&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;时下热门话题汇集，精彩享不停&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;大数据核心技术与实战峰会&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 演讲主题：大型互联网公司海量数据下的应用监控系统建设之道&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：为支撑海量数据和新业务的挑战，唯品会服务端有大大小小上千个业务域，也部署了近2万台物理机。同时，随着服务化和容器化技术的推广，使得整个生产环境部署架构相当复杂。为了有效对生产环境的应用系统提供360度全方位的监控，唯品会独立研发了应用监控系统，在系统建设过程中，也积累了丰富的经验。例如如何构建企业级的应用监控系统，如何应对海量亿级别数据的监控，以及当中踩过的一些坑。此次分享就为听众一一道来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 演讲主题：蘑菇街实时数据平台实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：蘑菇街的实时数据平台服务于业务数据监控、广告自然排序、系统分析等多个业务领域，在整个实时数据平台建设中包括多种关键技术的选型与二次开发，包括MySQL、ES、Storm、Esper、HBase、Spark等，针对不同的需求组合使用；与此同时作为一个数据仓库，数据的治理与业务的梳理与底层技术同样重要，三者缺一不可。本次分享的主要内容包括：蘑菇街实时计算平台Mario，数据链路的治理和不同的应用场景的介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 演讲主题：Machine Learning in Anomaly Detection&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：发现问题、解决问题是运维永恒不变的两个主题。而如何发现问题，是其中的难点和重点。运维收集的数据可能数以百万计，如何从其中快速、准确的发现问题（即异常检测）？这是本次演讲要讲的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;演讲有三个部分，首先从更加抽象、一般化的角度介绍异常本身以及异常检测的定义。然后，从“静态阈值法”开始，介绍多种异常检测的算法和实现，希望能通过更数学的方式，让大家对目前流行的几种异常检测方法的优缺点有所了解。最后一部分会着重介绍使用机器学习的方法，介绍一些对异常检测有很大提升的算法，通过真实数据和例子，演示机器学习对于异常检测的帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. 演讲主题：饿了么大数据基础架构实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：数据架构作为数据运营的基础部门，从2015年成立到现在经历了快速的发展，系统规模经历了几十倍的增长，这次主要为大家分享”饿了么”数据架构在离线、实时和工具方面的建设经验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 演讲主题：有赞大数据实践之敏捷型数据平台的构建及其应用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：本演讲首先介绍了有赞数据平台的设计思路和方法。我们为什么要设计数据仓库？数据仓库如何适应业务的变化？在数据的易用性方面有哪些措施？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后介绍构建在数据仓库上的BI系统及其应用，接下来我们介绍了大数据平台在搜索引擎方面的实践。在作者的演示中我们看到的是一个接地气的，在数据运营和研发效率上都能发挥作用的大数据平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6. 演讲主题：Echo探索个性化推荐和版权识曲之路&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：通过Echo回声App的用户的播放、喜欢、分享、下载等行为隐式数据，使用logistic matrix factorization模型，获取用户的特征向量和音乐的特征向量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了检测用户上传的歌曲是否属于未收录版权的歌曲，通过分析音乐的音频，进行频谱变换以及特征学习，生成对应的音频指纹。然后根据音频指纹判断用户上传歌曲是否侵权。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7. 演讲主题：小米广告大数据与算法实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：依托于强大的MIUI系统、2亿手机用户和完善的生态链布局，小米在过去几年积累了海量用户数据。本次分享将介绍大数据在小米广告平台的各种实践，包括收入提升、广告主优化、用户体验优化等。具体内容包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;小米数据资产布局，全生态多样性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;小米广告业务简介：四大业务线（效果，品牌，工具，联盟）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;小米效果类广告优化实践：个性化算法对应用分发和信息流广告数倍收入的提升&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;小米品牌类广告优化实践：如何利用大数据和精准用户画像帮助品牌广告主提高营销效率&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;小米工具类广告变现实践：如何通过大数据和机器学习，提升收益的同时优化用户体验。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结：大数据在广告变现中的各种坑和经验总结。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;8. 演讲主题：in数据服务架构演进&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：介绍in数据服务从初创到支持亿级用户, 从单点服务到高可用集群服务, 从简单CRUD到融合实时大数据挖掘推荐的演变过程, 以及这一过程中我们的经验和教训。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;9. 演讲主题：Apache Flink在万达金融的实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍： Apache Flink是开源社区最近两年发展非常迅速的一个分布式计算框架，其在时间窗口，唯一消息处理等功能特性，以及延迟，吞吐量等性能方面都在众多的流计算框架中独树一帜。本次分享主要介绍万达金融大数据部门基于Apache Flink支撑的各种业务，我们为何选择Aapche Flink，以及我们在使用，维护中遇到过的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;互联网应用架构峰会&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 演讲主题：SOFA - 可以预测未来的微服务开发框架&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：高内聚低耦合一直是所有架构工作者进行架构设计的理念和原则，近年来微服务架构的盛行可以说是这一理念的升华。虽然现阶段存在很多种RPC框架，或者基于RESTFul设计理念，可以让我们非常容易的实施微服务架构，但是很多架构师在对存量系统进行微服务拆分过程中，都是往事不堪回首。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为此，百度网页搜索架构部历时一年半的时间，设计开发了SOFA(Service Oriented Flyweight Architecture)这一轻量级的面向服务的开发框架，强调”以不变应万变”的宗旨，为服务开发者提供了接口化，组件化以及多语言的开发平台。SOFA强调一切皆是接口，一切皆是组件的设计原则，即使单独的一个服务进程，却仍然采用微服务的接口化设计和实现思路。当单个服务性能不足的时候，可以通过修改配置的方式，将原来进程内的接口调用，转换为远程的RPC调用，或者转换为不同编程语言的组件调用，轻松的实现微服务架构的拆分，从而非常容易的应对后续业务变化带来的对架构的冲击。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 演讲主题：QQ会员基于hybrid的高质量H5架构实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：任何技术优化都依托于业务的发展，随着QQ会员增值业务的重心转移到手Q移动端，对H5页面不仅要求加载更快，还需承载丰富多彩的运营活动，同时由于每个页面都意味着KPI收入，任何可能导致页面功能不可用的发布行为都是不可接受的。本次分享主要介绍QQ会员的前端开发团队在手Q的hybrid模式下对H5页面的性能优化、组件化和持续集成方面的实践。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 演讲主题：京东交易架构演进-高可用服务的保障&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：京东商城交易平台的架构，大促中的技术演进之路。分布式结构思路；合适时机进行拆分；高并发、高可用、如何诞生的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. 演讲主题：网易蜂巢云平台优化实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：从私有云到公有云的建设，由于场景及服务对象的转换，复杂需求功能和业务频繁迭代，因此如何将平台架构设计成灵活性、可扩展性、可运维性等有很高的要求，服务SLA等需求特性也必须放在重要位置。所以，蜂巢对平台整体架构进行了一系列的优化演变，具体包括底层基础设施、编排系统、容器服务等，本主题主要分享云服务构架的平台建设和系统优化实践。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 演讲主题：Hybrid框架在电商系统中实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：随着各个电商平台竞争日趋激烈，来自市场和运营的压力也越来越大。APP并不是一个封闭的环境，而且移动给市场和运营提供了新的机遇。这都需要我们从技术上挖掘APP的潜力，将之前的劣势转换成优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们应该从三个主要的层面来解决以上这些挑战：应用内Hybrid应用框架的扩展，Native和内嵌Web页面的互通和互联；应用和应用之间的互通和互联；线上和线下场景的互通和互联。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6. 演讲主题：大众点评数据库访问层的架构设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：本次分享主要介绍大众点评数据库访问层的架构设计。从为什么需要数据库访问层出发，介绍它的必要性。然后主要侧重从纯技术角度介绍zebra是如何实现读写分离，分库分表以及它的动态特性是如何发挥重要的作用的。最后会分享一下围绕这个访问层的运维体系的建设工作，和大众点评分库分表的一些实战经验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7. 演讲主题：唯品会应用系统架构设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：唯品会作为一家全球最大的特卖电商系统，闪购限时特卖业务特点决定了网站随时都需要处理高并发、大流量的用户请求。为了保证系统在高并发、大流量访问下工作，并且使系统有较强的扩展性。本次共享将介绍唯品会系统基础架构体系，以及唯品会应用系统架构的设计原则和思路，如合理系统逻辑拆分、分层设计、服务化解耦、适度的服务颗粒度划分、系统间通讯增加异步处理，减少同步处理、优化数据库访问、通过统一的数据共享标准、统一框架整合定时任务等，并通过订单和选购线中一些设计实例来说明服务化的设计思想。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;8. 演讲主题：苏宁的库存系统架构演进及架构设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：本次分析主要涉及库存业务介绍，库存系统演进，平台库存架构（包括应用架构、集成架构、数据架构、部署架构），经验总结和工作展望。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;9. 演讲主题：互联网网站性能优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主题介绍：本分议题着重和大家讨论引发服务器端性能问题和网络性能问题的各种影响因素，以及在这些现象背后的最基本的原理是什么，根据这些原理，我们去年大促顺利的解决了150个技术问题，这些体系化的知识为大促的顺利进行发挥了重要作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;四&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;已云集诸多杭州内外的互联网公司，你还在等什么？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本次峰会自官网上线十多天的时间里，已经获得了大批公司和个人的支持，以下精选了部分已经报名参会的杭州企业和高校：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网易杭州研究院&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;浙江大华技术股份有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;杭州华卓信息科技有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;杭州海康威视数字技术股份有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;浙江学海教育科技有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;浙江高速信息工程技术有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;浙江易舸软件有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;浙江浙大万维科技有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;浙江每日互动网络科技股份有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;杭州易和互联软件技术有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;杭州鼎夏科技有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;浙江浙大网新众合轨道交通工程有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;绿云科技有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;宁波力鼎软件科技有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;杭州快便付信息技术有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重庆云途交通科技有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;江苏惠银科技股份有限公司杭州分公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;浙江财经大学&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，本次峰会还获得了全国互联网公司的支持，北上广深和山东、安徽、河南、福建、内蒙古等都有企业和高校报名参会：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;北京市计算中心&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中国科学院软件研究所&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;腾讯科技（深圳）有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;北京金银网银信息技术有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上海店达信息技术有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;河南优蓓教育科技有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;潍坊安盾软件科技有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上海百联全渠道电子商务有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内蒙古校信通教育科技有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;山东威尔数据股份有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;郑州金惠计算机系统工程有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;厦门宏庚航海科技公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;天泽产业股份信息有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;易联支付有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上海淘利资产管理有限公司&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;河南理工大学&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;荆楚理工学院&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;五&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;高逼格会议品质，享受北上广同等级标准&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在一个会场，几百人的情况下，往往传统的投影仪，即使是在最高清以及现场设置四个幕布的情况下，中后排的参会嘉宾看得都不太清晰。所以，我们包括在成都，甚而现在的杭州，都采用了LED的大屏显示，我们会请讲师在制作PPT的时候，会多注重字体大小、图案设计等，让你身在会场的哪一个位置都能够得到最佳的参会感受。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，我们现场会设置微信群，及时共享课件，以及在群里请讲师在分享结束后，可继续深度交流。你获得的不仅是听课，而是和讲师平等的互动交流，这也是我们所提倡的，技术本应平等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有包含午餐、会场午餐等等，我们也都精心设计和慎重选择，以及会场近地铁1号线城站仅仅不到30米，通过诸多细节体现了主办方CSDN的用心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;六&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;专家力荐，你值得拥有&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;始建于2007年的SDCC，已经成功举办七届，历届技术讲师超过550位，参会人数超过7500人，成为技术圈口碑卓越的技术会议品牌。历来，也获得了专家的力荐：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;胡峰 京东成都研究院智能通讯部资深架构师&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;8月份刚刚结束的SDCC成都站，机缘巧合受邀参加，这也是SDCC第一次在成都举办，但火爆程度超出预期。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给我的感觉是SDCC邀请的主讲嘉宾都是真正在一线积累颇为深厚的技术精英，一路听来，干货满满，启发良多，受益颇丰。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这里有可能会给你带来启发和指引，也有可能给你机会去和前方的同行深度交流，面对SDCC你还在犹豫什么？&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，希望SDCC越办越好，成为技术人在黑暗中摸索航行的灯塔。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;李林锋 华为PaaS平台架构师&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;8月份有幸参加了SDCC成都站峰会，结识了很多国内一线的专家和技术大牛，讲师们带来的分享都是最前沿、最实用的干货，通过跟各位专家交流，我自己也受益匪浅。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SDCC杭州站峰会聚焦在大数据核心技术以及互联网架构，邀请的都是实战经验丰富的一线技术专家，相信一定会给大家奉献一场精彩的技术盛宴。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;欧阳辰 小米研发架构师&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;SDCC大会是互联网架构师的盛会，有幸参加今年成都站的SDCC，感受到大会几个特点：干货充实厚重、实践见微知著、思考望其项背、选题海纳百川、组织井井有条。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;架构作为大会的主线，把很多行业发展、组织架构、技术选型、算法机器学习、大数据分析等都关联起来，给参与者一个360度的视角。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这也是一个“三人行必有我师”的大会，参会者有机会认识很多志同道合的朋友，向行业专家指教，其中不少互动环节也是非常有趣、有乐、有红包的。这是一个不虚此行的大会。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想看更多专家观点，猛戳&lt;span&gt;这里&lt;/span&gt;就穿越。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;七&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;丰富奖品拿不停&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp7FaCqgNAxibdIuc7KGeuericaYW2CHI691EXxhiciblmMv7ykicz0whaictLQ/0?wx_fmt=jpeg"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了答谢参会嘉宾，现场将在QA环节等，发放数量不等的奖品（见上图）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp7KKxGTdDStm0tfHIDVepjNKUvVTvwaEqibibKb9LrTgibzqGMGIU5I2sng/0?wx_fmt=jpeg"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp7QMHKlmGrQS9AwtIhyRibialHXHibIfo3wV0f7boGicGLVK5qibs8ib10mWPA/0?wx_fmt=jpeg"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与此同时，在大会期间，我们还会赠送技术书籍，上图为成都站的部分赠书，而这次杭州站将会增加种类和数量，敬请期待。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参与技术大会，不仅可以获得本身技术的提升，还可以了解同行现在所用的技术，在埋头编码的同时，也要抬头看下世界，或者这样才能在激烈的互联网竞争中更从容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更多阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;专访京东杨超：出色的架构师应具备的素质&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;专访游族姚仁捷：机器学习和异常检测相结合，提升运维能力&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;专访有赞洪斌：精细化平台架构带来数据价值最大化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;SDCC 2016系列全回顾：数据库&amp;amp;大数据&amp;amp;运维&amp;amp;架构（附50 + PPT下载）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp7UAIwOEctXgUfIqBA3v7m2xYJOYZu7uAWtRztIcHKcawIlcmLySdYbg/0?wx_fmt=jpeg"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;</description>
      <pubDate>Fri, 09 Sep 2016 16:48:18 +0800</pubDate>
    </item>
    <item>
      <title>提交深度学习优质内容 即可拿奖品</title>
      <link>http://www.iwgc.cn/link/2625174</link>
      <description>&lt;p&gt;&lt;span&gt;谷歌AlphaGo战胜围棋世界冠军李世石，点燃了人们对人工智能、深度学习领域的深度思考与关注。不仅如此，深度学习正在潜移默化地走进我们的生活。比如，你在电商网站上面浏览某类商品，比如电吹风，那么，他们会根据你的浏览记录推荐N种电吹风给你。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此以外，广大开发者也非常期望能有系统、优质、结构化的深度学习资源推送给大家。专家坐阵，精选优质干货的深度学习知识库或许可以祝你一臂之力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，该库正在筹备之中，前往关注深度学习知识库筹备计划&lt;span&gt;=&amp;gt;&lt;a target="_blank" style="box-sizing: border-box; color: rgb(51, 122, 183); background-color: transparent;"&gt;http://lib.csdn.net/assemble&lt;/a&gt;。&lt;/span&gt;现急需大家贡献一份力量，&lt;span&gt;搜罗全网优秀的深度学习资源。大家只需把优秀的文章标题和和链接发布到下方的评论里即可，无需原创，只要内容符合深度学习主题，内容靠谱、实战、干货即可&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章经过专家审核通过后，即可被知识库采用。文章采用量达到5条以上，即有礼品赠送噢，有CSDN定制的T恤、超大鼠标垫、马克杯，贡献特别突出的还有CSDN定制的精美背包，活动截止于9月29日，大家赶快行动噢，先推荐内容先得奖品呦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjXtCmPibXiapKdaULqsoPHRSGeicr2aeWRlFMTSkRuSkKdN5SuBjojsk9icMO7KvdSAwzaeYKwLvpeATw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更多内容请关注&lt;/span&gt;&lt;a target="_blank" style="box-sizing: border-box; color: rgb(51, 122, 183); font-size: 14px; text-decoration: underline; background-color: transparent;"&gt;&lt;span&gt;CSDN知识库&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。该产品汇集了领域专家们精心绘制的各重点技术领域的知识图谱，及由特邀编辑（领域专家）从海量数据中层层筛选出的精华内容和资源（学习视频、实践Demo、图书）。知识图谱可以帮助开发者全局把控该技术领域，而精选内容更能让开发者从技术细节加深了解该领域的每个核心技术点。扫描以下二维码，获取更多CSDN知识库内容。&amp;nbsp;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;center style=" box-sizing: border-box; color: rgb(51, 51, 51) ; ; ; ; ; ; "&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjXtCmPibXiapKdaULqsoPHRSGnNeJd89CWoFyr0Z4ATMz0icR9d3guBMA7Oa9AhBma6ibMxtnuGREsiaDw/0?wx_fmt=jpeg"/&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;没你喜欢的库怎么办？来攒库，快戳=&amp;gt;&amp;gt;&lt;a target="_blank" style="box-sizing: border-box; color: rgb(51, 122, 183); background-color: transparent;"&gt;http://lib.csdn.net/assemble&lt;/a&gt;，想建什么库，你说了算！&lt;/span&gt;&lt;/p&gt;</description>
      <pubDate>Fri, 09 Sep 2016 16:48:18 +0800</pubDate>
    </item>
    <item>
      <title>《程序员》：信息无障碍的发展和技术实践</title>
      <link>http://www.iwgc.cn/link/2613605</link>
      <description>&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;本文为《程序员》原创文章，未经允许不得转载，更多精彩请订阅2016年《程序员》&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“信息无障碍”起源于西方发达国家，译自“Accessibility”，指任何人在任何情况下都能平等、方便、无障碍地获取并利用信息。本文将从身体障碍和信息障碍、法规和标准、产品和技术实践，这三个方面介绍信息无障碍的发展和实践经验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当Tim Berners-Lee发明万维网时，他的美好愿景是Web for All，这意味着让所有人都能对Web加以利用，不论文化教育背景、能力、财力以及身体残疾。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在信息技术高速发展的今天，很多人没有网络都觉得没法生存，但是在这个星球上，数以亿计的人是被信息技术远远抛下的群体。他们是失明失聪的残障人士，或者是贫困农村的失学儿童，又或者是不会使用互联网的老年人。这就是所谓的信息障碍。信息无障碍是愿景，而信息障碍是需要面对的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;身体障碍 VS. 信息障碍&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“信息无障碍”经常被人们认为是为残障人士提供的某种特别服务或工具。这种想法无可厚非，毕竟，残障人士是信息障碍最大的受限群体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是让我们换一种方式思考，什么是障碍？前方的道路有条河流，没有轮渡也没有桥梁；或者是迷失在高速公路上，没有导航设备也没有清晰的路标。这些都是障碍，但这样的障碍是人类可以解决的，或者说是人为造成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信息障碍类似于此，人们总是可以找到通用的、辅助的解决方案，或许会有滞后，但必然会出现的。举两个例子，对于很多不了解无障碍技术的人来说，视障人士是不能使用电脑的，听障人士是不能使用电话的，实际上，帮助聋哑人士使用电话的TDD（Telecommunications Device for the Deaf）技术在20世纪60年代产生（国内电信行业由于时间周期、语言等原因，没有引进该技术）；帮助视障人士使用电脑的读屏软件在80年代就已出现；我们可以看到那些复杂的信息障碍一样也能被跨越。要强调的是，信息障碍不是某类人群的障碍，而是某类信息技术产品缺少人性化、通用性思维造成的，并且这类障碍是有方法解决的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp7iaL7h0X5hm99S6kvQ1Io6OXW3Fl3PYprOd49JhPicJJgMr6jTKR17t0w/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1 早期的TDD设备，语言形式通过文字和语音形式同时传输&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;法规 VS. 标准&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Tim Berners-Lee 1997年在W3C内部成立了WAI（Web Accessibility Initiative），负责开发Web无障碍相关标准，该组织在1999年完成了Web内容无障碍指南1.0（Web Content Accessibility Guidelines 1.0，WCAG 1.0）的开发，其后在2008年重新制定了WCAG 2.0，虽然WCAG以及2.0这个版本的制定主要针对Web内容，但它也确定了信息无障碍的四个基本原则：可感知性、可操作性、可理解性、鲁棒性，以及信息障碍可能覆盖的几类残障人群。在近二十年的时间里WAI围绕着WCAG开发了一系列相关规范，涉及用户代理、开发工具，以及语义标签。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美国1973年建立了《康复法案》，所有政府资助的项目，禁止对于残障人士的就业歧视。2000年前后，《康复法案》完善了补充法规 – Section 508，除了节选当时的WCAG 1.0（Web Content Accessibility Guidelines 1.0）以外，也对其它信息产品（Electronic and Information Technology）进行了无障碍实施定义，包括数字文档、闭路产品、沟通技术等，法规的建立进一步规范了美国国内的无障碍技术依据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;产品 VS. 技术实践&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美国作为信息产品、技术生产大国，对于信息无障碍的相关标准、法规、技术方法，甚至是投诉机制的完善，也促进了传统的IT企业和新兴互联网企业开始重视这个领域，并重新审视这个领域的价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IBM&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1999年，IBM开发了内部产品无障碍标准（Corporate Instruction 162，CI 162），该规定要求IBM自身的软件、硬件、Web应用，甚至是对内对外服务都应该具有无障碍特性及接口。2000年左右，IBM成立无障碍研究中心，隶属于研究院，专注于研究、开发残障人士使用IT技术，并且通过这类研究提高产品通用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp7B6Q5ficwBnoz85MibEuKyMRbZjiaflz8P0CAZEo0PAXk0eKnapugWhK6w/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2 IBM的Easy Web Browsing&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信息障碍的基本辅助手段之一是文字转语音技术（Text to Speech，TTS）和语音识别技术，IBM充分发挥自己在这些技术的强项，二十年前就有了通用性很强的语音识别软件——ViaVoice，功能上基本就是单机版的Siri；专门为视障用户使用辅助浏览工具的Home Page Reader，配备多种语言版本的TTS。IBM信息无障碍中心早期的产品——Easy Web Browsing是一个浏览插件，帮助有低视力（非全盲）、色盲、色弱、学习障碍等用户浏览网络，这款产品简单易用，运用范围很广。而aDesigner是IBM早期的网站无障碍评估工具，已经开源到Java社区，更名为ACTF。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Apple&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Apple的产品简单易用到极致，例如iPhone，虽然外形简单，但是内置的辅助功能和系统平台无缝衔接，辅助工具VoiceOver更是与系统应用完美结合，使得iPhone一直以来都能在残障群体里广受好评。其实，当iPhone刚刚推向市场时，由于完全抛弃了物理键盘，并且没有任何辅助技术接入，被视障群体诟病多年，直到iOS 3.0添加了辅助技术，并且完善了iOS开发的无障碍接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp76EDCXHrpaSvHAtjO3alLuvqP1HOtsItIGLd3PtnIbv1H8n6oJEziaWA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3 视障用户可以方便的使用iOS和Mac设备内置的VoiceOver&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随后，iOS不断添加通用性的平台应用，如FaceTime和Siri, 这些应用不仅让年青用户觉得很有乐趣，对于残障人士也很有益处，FaceTime的视觉形式交流可以让听障用户用手语交流，而Siri的引导式访问，能够快速启动平台应用，对于视障和肢体障碍用户帮助很大。除此以外，一些独特的内置功能、特性，也对残障人士极为友好，例如单声道音频，帮助单耳失聪或者重听的用户更好地使用音频声道。第三方软件，更可以帮助严重的自闭症患者学习、交流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Google&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;和传统的IT企业比起来，互联网企业的用户基数更为巨大，他们对于无障碍的重视也不仅仅停留在标准、法规上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Google作为互联网领军企业，产品已不单限于互联网，其主要产品都已经具有无障碍特性，或者增加了无障碍接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Android——众所周知的移动平台应用，和iOS一样，做了无障碍优化，并完善了开发无障碍的接口，很遗憾的是，国内很多手机厂商，把这个重要模块阉割了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp78pnrbdpwiafdZN2xRO5e3RXQXzibcvBtTOyd86gCT05ZSfyx9ibpA2eVA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4 包含多种类型字幕的YouTube视频，方便让视障人士和听障人士获取视频中的信息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;浏览器是和Web结合最紧密的用户代理，它和读屏软件一起帮助视障用户获取互联网信息，它对无障碍语义标签的支持，决定了视障用户获取信息的多少。Chrome浏览器对无障碍语义标签的支持一直都是最好的，不仅如此，它也扩展了其它形式的无障碍支持，比如丰富的快捷键、无障碍扩展、第三方无障碍测试工具。而Google旗下YouTube视频网站，通过字幕帮助听障人士获取信息，字幕的添加使用的是语音识别技术和字幕编辑软件结合完成，而语音识别的准确率则以Google积累深厚的大数据为基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Facebook&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Facebook是Web 2.0的先驱，它在信息无障碍的很大挑战是，大量数据、图片、文字由用户创造，在无障碍范畴里，图片只有添加了相应的替代文本，或者有意义的语义标签才能被辅助工具使用，让视障人士能够了解图片含义，但是Facebook并不能强行要求用户去为某个图片添加无障碍的语义标签和替代文本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp74s6oFVctzdibWgsjdkobEqCiawUI3R1gtFyYs08kGa1lIg6YRPTRPzmQ/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5 Facebook的iOS应用，可以自动识别图像内容，并朗读出来&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是Facebook并未放弃对信息无障碍的探索，2016年初，Facebook宣布通过人工智能技术帮助视障人士使用其应用，方法就是自动识别图像内容，为用户上传的图片添加替代文本，并将该文本朗读出来，帮助视障用户“看到”图片的内容，和Google的语音识别一样，图像的识别也是通过大数据完成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;编外&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到信息技术虽然高速发展，也一直在完善它的不足。现代技术的叠加、互相补充，让信息无障碍技术富有想象力和创造力，不仅帮助残障人士使用信息产品，让他们公平地获取信息，也帮助信息产品的通用性、人性化提升到新的高度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;作者：张昆，信息无障碍研究会首席专家。拥有近20年的信息无障碍理论及实践经验，曾任职IBM大中华区信息无障碍中心专家、W3C中国区信息无障碍事务负责人，参与了“2008年北京奥运会信息无障碍方案”、“W3C信息无障碍标准制定”等重大项目。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;移动端无障碍产品开发，是移动端产品的主要特性之一，常被开发者忽视，但是这样的特性却影响数以百万计的用户人群，那么应该如何打造移动端产品的无障碍呢？在MDCC 2016上，张昆将带来题为《移动端无障碍产品开发》的分享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更多精彩尽在MDCC 2016，详情请查看大会官网：http://mdcc.csdn.net/。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;2016 年 9 月 23-24 日，由 CSDN 和创新工场联合主办的“MDCC 2016 移动开发者大会• 中国”（Mobile Developer Conference China）将在北京•国家会议中心召开，来自iOS、Android、跨平台开发、产品设计、VR开发、移动直播、人工智能、物联网、硬件开发、信息无障碍10个领域的技术专家将分享他们在各自行业的真知灼见。大会门票8折优惠中，五人以上团购更特惠，限量供应（&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;获取票务详情，8折优惠，欲购从速！）&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;</description>
      <pubDate>Thu, 08 Sep 2016 19:59:01 +0800</pubDate>
    </item>
    <item>
      <title>李理：从Image Caption Generation理解深度学习（part II）</title>
      <link>http://www.iwgc.cn/link/2613606</link>
      <description>&lt;p&gt;&lt;span&gt;本系列文章面向程序员，希望通过Image&amp;nbsp;Caption&amp;nbsp;Generation，一个有意思的具体任务，深入浅出地介绍深度学习的知识，涉及到很多深度学习流行的模型，如CNN，RNN/LSTM，Attention等。本文为第二篇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者李理，MDCC&amp;nbsp;2016&amp;nbsp;移动开发者大会人工智能与机器人专场的出品人，邀请人工智能一线专家担任演讲嘉宾，从无人驾驶、智能机器人、智能应用开发实战等方面解读人工智能技术的内涵及其对移动开发工作的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;书接上文：李理：从Image&amp;nbsp;Caption&amp;nbsp;Generation理解深度学习（part&amp;nbsp;I）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;2. 机器学习基本概念和前馈神经网络&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;2.1&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;机器学习基本概念&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家可能平时都写过很多程序，写程序和机器学习的思路可能有一些不同。写程序时，我们是“上帝”，我们规定计算机的每一个步骤，第一步做什么第二步做什么，我们称之为算法。我们能够控制所有的情况，如果出了任何问题，肯定都是程序员的责任。而在机器学习的时候，我们只是“老师”。我们告诉学生（计算机）输入是什么，输出是什么，然后期望它能够学到和我们类似的知识。比如我们跟小孩说这是狗，那是猫，我们没有办法像上帝那样拿着“纳米手术刀”去操作人脑神&amp;nbsp;经元的连接方式。我们只能不断的给小孩“训练数据”，然后期望他能够学会什么是猫，即使我们觉得他“学会”了识别猫，我们也没有办法知道他是“怎么”学会&amp;nbsp;的，而且同样的训练过程可能换一个人就不好使。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;机器学习和人类的学习是类似的——我们也是给它训练数据，然后期望它能学会。我们会给机器建一个模型，从数学的角度来说一个模型就是一个函数，它的输入一般是一个向量【当然可以是二维的矩阵如图片或者三维的张量比如视频】，输出可以是有限的离散的标签如“猫”，“狗”，这类问题我们称之为分类；而如果输出&amp;nbsp;是连续的值比如用这个模型来预测气温，那么我们就称之为回归。其实人类的很多科学活动和日常生活，都是在“学习”模型和“应用”模型。比如开普勒通过观测&amp;nbsp;大量天文数据“归纳”出行星的运动规律。从本质上讲，智能就是从“过去”学习，然后根据“现在”来预测可能的将来并根据自己的目标选择有利于自己行为。只不过之前，似乎只有人类能够从数据中“学习”出规律，而人工智能的目标就是让机器也有类似的学习能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;模型用数学来说就是一个函数，我们人脑的函数由神经元的连接构成，它可能是一个很复杂的函数，我们现在还很难彻底研究清楚。神经网络就是试图通过计算机来&amp;nbsp;模拟和借鉴人脑这个模型，除了我们这里要讲的神经网络之外，机器学习领域还有各种各样的模型，它们各有特点。但不管形式怎么变化，本质都是一个函数。一个（或者更准确的是一种）模型一般都是一种函数形式，它有一些“参数”可以改变。而学习的过程就是不断调整这些参数，使得输出（尽量）接近“正确”的答案。&amp;nbsp;但是一般情况下很难所有的数据我们都能预测正确，所以一般我们会定义一个loss&amp;nbsp;function，可以理解为“错误”的程度，错的越“离谱”，loss就越大。而我们的目标就是调整参数使得loss最小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是我们是在“训练”数据上调整的参数，那么它能在“测试”数据上也表现的好吗？这个就是模型的“泛化”能力了。就和人在学校学习一样，有的同学做过的一&amp;nbsp;模一样的题就会，但是考试时稍微改变一下就不会了，这就是“泛化”能力太差，学到的不是最本质的东西。所以平时会定期有一些“模拟考试”，来检验学生是不&amp;nbsp;是真的学会了，如果考得不好，那就打回去重新训练模型调整参数。这在机器学习里对应的就是validation的阶段。最后到最终的考试了，就是最终检验&amp;nbsp;的时候了，这个试卷里的题目是不能提前让人看到的，只能拿出来用一次，否则就是作弊了。对应到机器学习里就是test阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然这里用通俗的话描述了机器学习，主要是有监督的学习。其实机器学习还有无监督的学习和强化学习。前者就是不给答案，只给数据，让人总结规律；而后者会有答案，但是答案不是现在就告诉你。我个人觉得人类社会里更多的是监督学习和强化学习。从人类社会总体来说，强化学习是获取新知识的唯一途径，也就是向自&amp;nbsp;然学习，我们做了一个决策，其好坏可能要很长一段时间才能显现出来。而学习出来的这些知识通过监督的方式，通过家庭和学校的教育教给下一代。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外输出除了简单的分为离散和连续，还可以是序列（时序）的，比如自然语言（文本）是一个字符串的序列&amp;nbsp;，对于我们的Image&amp;nbsp;Caption&amp;nbsp;Generation就是生成一个单词序列。另外还有更复杂的输出，比如parsing，输出是一棵语法树。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;2.2&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;多层神经网络&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面介绍了机器学习的基本概念，接下来我们就来学习一下神经网络。现在流行的说法“深度学习”，其实大多指的就是“深度神经网络”，那么首先我们先了解一下“浅度神经网络”，也就是传统的神经网络。这里的内容主要来自&lt;span&gt;http://neuralnetworksanddeeplearning.com&lt;/span&gt;的前两章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2.1&amp;nbsp;手写数字识别问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在学习一门新的语言时会写一个hello&amp;nbsp;world程序，而mnist数据的手写数字识别就是一个很好的学习机器学习（包括深度学习）的一个hello&amp;nbsp;world任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;计算机和人类大脑似乎有很大的不同，很多人类认为复杂的工作计算机可能认为很简单，而人类认为很简单的事情计算机可能非常难处理。比如数字的计算，记忆，人类的准确度和速度都远远不如计算机。但是识别0-9的手写数字，我们觉得很轻而易举的事情，让计算机程序来处理却异常困难。经过数百万年进化的人类视觉系统在我们大脑没有意识到的时候就已经帮我们完成了数字的识别，把那些复杂的视觉处理过程深深的掩藏了起来。但当我们想自己写一个程序来识别数字的时候，这些困难才能体现出来。首先，对于计算机来说，它“看到”的不是数字，甚至不是笔画。它“看到”的只是一个二位的矩阵（数组），每个点都是一个数字。比如下图，我们“看到”的是左边的“猫”，其实计算机“看到”的是右边的像素灰度值。当然我们视觉系统的视网膜看到的也是类似的一些“数值”，只不过我们的视觉系统已经处理了这些信息并且把它识别成了“猫”（甚至和语言还做了映射）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcskfN7Sfq38pGrefoWx2NakJBX3GarG9ANl9Zv3LICAwHdRNjWmAnQzw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MNIST数据介绍：MNIST的每个图片经过缩放和居中等预处理之后，大小是28*28，每个点都是0-255的灰度值，下图是一些样例。总共有60,000个训练数据（0-9共10个类别，每个类别6,000个）和10,000个测试数据。一般会拿60000个中的50000个来做训练集，而剩下的10000个用来做验证集（用来选择一些超参数）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsL9wvuNCNevcCG1t6KtHp4AK8ERsUasxBnW5mDl6SfDQnibqHR4r0ibGw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;mnist样例数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;如果我们自己来写一个“算法”识别数字“9”，我们可能会这么定义：9在上面有个圆圈，在这个圆圈的右下部分有一个竖直的笔画。说起来很简单，如果用算法&amp;nbsp;来实现就很麻烦了：什么是圆圈？每个人画的圆圈都不同，同样竖直的笔画怎么识别，圆圈和竖直笔画连接处怎么寻找，右下是哪？大家如果有兴趣可以尝试一下用&amp;nbsp;上面的方法，其实最早做数字识别就是这样的思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;机器学习的思路则不同，它不需要这么细节的“指示”计算机应该怎么做。而是给计算机足够的“训练”样本，让它“看”不同的10个数字，然后让它“学”出&amp;nbsp;来。前面我们也讲了，现在的机器学习一般是一个参数化的模型。比如最简单的一个线性模型：f(w;x)=w0+&amp;nbsp;w1*x1+w2*x2。如果我们的输入有两个“特征”x1和x2，那么这个模型有3个参数w0,w1和w2，机器学习的过程就是选择“最优”的参数。对&amp;nbsp;于上面的mnist数据，输入就是28*28=784维的向量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果用“原始”的输入作为“特征”，线性的模型很可能学到一些简单的特征，比如它看到1一般是分布在从上到下居中的一些位置，那么对于这些位置一旦发现有比较大的灰度值，那么就倾向于判断成1。如果一个像素点2也经常出现，但3不出现，那么它就能学到如果这个像素出现，那么这个数字是2和3的可能性就大一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是这样的“特征”可能不是“本质”的，因为我写字的时候笔稍微平移一点，那么你之前“学到”的参数就可能有问题。而更“本质”的特征是什么呢？可能还是像之前我们总结的——9在上面有个圆圈，在这个圆圈的右下部分有一个竖直的笔画。我们把识别一个数字的问题转化成圆圈和竖直笔画的问题。传统的机器学习需要方法来提取“类似”（但不完全是）基本笔画这样的“特征”，这些特征相对于像素的特征会更加“本质”。但是要“提取”这些特征需要很多的“领域”知识，比如图像处理的技术。所以使用传统的机器学习方法来解决问题，我们不但需要很多机器学习的知识，而且也需要很多“领域”的知识，同时拥有这两方面的知识是比较难的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而“深度学习”最近之所以火热，其中很重要的一个原因就是对于很多问题，我们只需要输入最原始的信号，比如图片的像素值，通过“多层”的网络，让底层的网络学习出“底层”的特征，比如基本的形状，而中间的层学习出抽象一点的特征，比如眼睛鼻子耳朵。而更上的层次识别出这是一个猫还是一个狗。所有这些都是机器学习出来的，所以基本不需要领域的知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsNyc6fnKpX7xAZtYJtUibx66DbBKberBCKaYT5jrJG2MZIJicMCkEiaM1g/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面的图就说明了这一点，而且我们发现越是底层的特征就越“通用”，不管是猫鼻子还是狗眼睛，可能用到的都是一些基本的形状，因此我们可以把这些知识（特征）transfer到别的任务，也就是transfer&amp;nbsp;learning，后面我们讲到CNN的时候还会提及。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2.2&amp;nbsp;单个神经元和多层神经网络(MLP)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;神经网络从名字来看是和人类的大脑有些关系的，而且即使到现在，很多有用的东西如CNN和Attention，都有很多借鉴神经科学研究人脑的结果的。不过这里我就不介绍这些东西了，有兴趣的读者可以找一些资料来了解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个神经元如下图的结构：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsXSribFetfaHOqGPHlJLPLlliaJibMxcia99cpEz3RSzZic3GYfhKpevMOSw/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的输入是一个向量，(x1,x2,x3)，输出是一个标量，一个实数。z=w0+&amp;nbsp;w1*x1&amp;nbsp;+&amp;nbsp;w2*x2&amp;nbsp;+&amp;nbsp;w3*x3。z是输入的加权累加，权值是w1,w2,w3，w0是bias，输出&amp;nbsp;output&amp;nbsp;=&amp;nbsp;f(z)。函数f一般叫做激活函数。最早流行的激活函数是Sigmoid函数，当然现在更流行Relu和它的改进版本。Sigmoid函数的公式和图形如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsTLPEV0ewZOcPx4JMaDrd13XAhVNJn4AJefE72KwmZXYfKzAzOiaNtOw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsN47X6B7zfaSskJVabYArSaiaVkrcUZhhlRJjCszEbcwzkCDIibeV1dTg/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当z=0时，sigmoid(z)=0.5&amp;nbsp;z趋于无穷大时，sigmoid(z)趋近于1，z趋于负无穷，值趋于0。为什么选择这样的激活函数呢？因为是模拟人脑的神经元。人脑的神经元也是把输入的信号做加权累加，然后看累加和是否超过一个“阈值”。如果超过，继续向下一个神经元发送信号，否则就不发送。因此人脑的神经元更像是一个阶跃函数：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsnHWyvtsMiapBeicdTiakY8OqQJic2hbq3G2ia97icqmf4tnriafVjyOAWq4IA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最早的感知机(Perception)其实用的就是这个激活函数。但是它有一个缺点就是0之外的所有点的导数都是0，在0点的导数是无穷大，所以很难用梯度的方法优化。而Sigmoid函数是处处可导。下面我手工推导了一下，如果大家不熟悉可以试着推导一下Sigmoid函数的导数，我们后面也会用到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsNJ400iaCiaHGBPgKlYah09T8fZ1M7UbgZt0E9HqvLDcugicnNjkiaeZzCQ/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们把许多的单个神经元按照层次组织起来就是多层的神经网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsGU25H4l3YO6et5Gb6lVqUbUktcoC8mKnUlBbHCrZSqR2iaTmM7kUjyA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如我们的手写数字识别，输入层是784维，就是神经网络的地一层，然后中间有15个hidden（因为我们不知道它的值）神经元，然后输出层是10个神经元。中间隐层的每个神经元的输入都是784个原始像素通过上面的公式加权累加然后用sigmoid激活。而输出层的每一个神经元也是中间15个神经元的累加然后激活。上面的图就是一个3层的神经网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;输入一个28*28的图像，我们得到一个10维的输出，那么怎么分类呢？最直接的想法就是把认为最大的那个输出，比如输出是（10,11,12,13,14,15,16,17,18,19)，那么我们认为输出是9。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，更常见的做法是最后一次经过线性累加之后并不用Sigmoid函数激活，而是加一个softmax的函数，让10个输出加起来等于1,这样更像一个&amp;nbsp;概率。而我们上面的情况，虽然训练数据的输出加起来是1,但是实际给一个其它输入，输出加起来很可能不是1。不过为了与Nielsen的文章一致，我们还&amp;nbsp;是先用这种方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，假设我们有了这些参数【总共是784*15&amp;nbsp;+&amp;nbsp;15(w0或者叫bias)&amp;nbsp;+&amp;nbsp;15*10&amp;nbsp;+&amp;nbsp;10】，我们很容易通过上面的公式一个一个的计算出10维的输出。然后选择最大的那个作为我们识别的结果。问题的难点就在怎么&amp;nbsp;选择这么多参数，然后使得我们分类的错误最少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我们怎么训练呢？对于一张图片，假设它是数字“1”，那么我们期望它的输出是（0,1,0,0,0,0,0,0,0,0)，所以我们可以简单的用最小平方错误作为损失函数。不过你可能会有些疑问，我们关注的指标应该是分类的“正确率”（或者错误率），那么我们为什么不直接把分类的错误率作为损失函数呢？这样神经网络学习出来的参数就是最小化错误率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要的原因就是错误率不是参数的连续函数。因为一个训练数据如果分类正确那么就是1，否则就是0，这样就不是一个连续的函数。比如最简单的两类线性分类器，f(x)=w0+w1*x1+w2*x2。如果f(x)&amp;gt;0我们分类成类别1；否则我们分类成类别2。如果当前的w0+w1*x1+w2*x2&amp;lt;0，我们很小的调整w0(或者w1,w2)，w0+w1*x1+w2*x2仍然小于0，【事实上对于这个例子，只要是w0变小，他们的累加都是小于0的】所以f(x)的值不会变化，而w0一直增大到使累加和等于0之前都不会变化，只有大于0时突然变成1了，然后一直就是1。因此之前的错误率都是1，然后就突然是0。所以它不是个连续的函数。因为我们使用的优化算法一般是（随机）梯度下降的算法，在每次迭代的时候都是试图做一个微小的参数调整使得损失变小，但是不连续的函数显然也不可导，也就没法用这个算法来优化参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此我们使用了最小平方误差(MSE)损失函数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcs2s8jvzz0YlurYamEE9MDvQCxuJU51XicVpFtgtv7nicvXAk7F9eCY94A/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;y(x)就是神经网络的输出，可能写成f(x)大家会习惯一点。a是目标的输出，比如当前分类是数字1，那么我们期望的输出就是（0,1,0,0,0,0,0,0,0,0)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先这个损失函数是参数w的连续函数，因为y(x)就是神经网络的输出，每个神经元都是它的输入的线性加权累加，然后使用sigmoid激活函数【如果使用最早的阶跃函数就不连续了，所以后来使用了Sigmoid函数】，然后每一层的神经元都是用上一层的神经元通过这样的方式计算的（只不过每个神经元的参数也就是权重是不同的数值而已），所以这些连续函数的复合函数也是连续的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次这个损失函数和我们的最终优化目标是“大致”一致的。比如C(w,b)趋于0时，它就要求y(x)趋于a，那么我们的分类也就趋于正确。当然可能存在一种极端的情况，比如有3个训练数据，第一组参数，它分类正确了2个训练数据，但是错的那1个错的很“离谱”，也就是y(x)和a差距极大；而第二组参数，他正确分类了1个训练数据，但是错的那两个都还不算太差。那么这种情况下MSE和正确率并不一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2.3&amp;nbsp;随机梯度下降(Stochastic&amp;nbsp;Gradient&amp;nbsp;Descent)和自动求梯度(Automatic&amp;nbsp;Derivatives)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面说了，我们有了一个参数化的模型，训练的过程就是根据训练数据和loss&amp;nbsp;function，选择“最优”的参数，使得loss“最小”，这从数学上来讲就是一个优化问题。这看起来似乎不是什么值得一提的问题，也许你还记得微积&amp;nbsp;分里的知识，极值点的各种充分必要条件，比如必要条件是导数是0，然后直接把参数解出来。但在现实生活中的函数远比教科书里学到的复杂，很多模型都无法用&amp;nbsp;解析的方式求出最优解。所以现实的方法就是求“数值”解，一般最常见的方法就是迭代的方法，根据现在的参数，我们很小幅度的调整参数，使得loss变小一&amp;nbsp;点点。然后一步一步的最终能够达到一个最优解（一般是局部最优解）。那怎么小幅调整呢？像闷头苍蝇那样随机乱试显然效率极低。因此我们要朝着一个能使函数&amp;nbsp;值变小的方向前进。而在一个点能使函数值变小的方向有无穷多个，但有一个方向是下降速度最快的，那就是梯度。因此更常见的方法就是在当前点求函数的梯度，&amp;nbsp;然后朝着梯度的方向下降。朝梯度的方向走多远呢？一般走一个比较小的值是比较安全的，这个值就是“步长”。一般刚开始随机的初始化参数，loss比较大，&amp;nbsp;所以多走一些也没关系，但是到了后面，就不能走太快，否则很容易错过最优的点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为loss是所有训练数据的函数，所以求loss的梯度需要计算所有的训练数据，对于很多task来说，训练数据可能上百万，计算一次代价太大，所以一&amp;nbsp;般会“随机”的采样少部分数据，比如128个数据，求它的梯度。虽然128个点的梯度和一百万个的是不一样的，但是从概率来讲至少是一致的方向而不会是相&amp;nbsp;反的方向，所以也能使loss变小。当然这个128是可以调整的，它一般被叫做batch&amp;nbsp;size，最极端的就是batch是1和一百万，那么分别就是online&amp;nbsp;learning和退化到梯度下降。batch&amp;nbsp;size越大，计算一次梯度的时间就越久【当然由于GPU和各种类似SSE的指令，一次计算128个可能并不比计算1个慢多少】，随机梯度和真正梯度一致&amp;nbsp;的概率就越大，走的方向就更“正确”；batch&amp;nbsp;size越小，计算一次的时间就越短，但可能方向偏离最优的方向就更远，会在不是“冤枉路”。但实际的情况也很难说哪个值是最优的，一般的经验取值都是几&amp;nbsp;十到一两百的范围，另外因为计算机都是字节对齐，32,64,128这样的值也许能稍微加快矩阵运算的速度。但是实际也很多人选择10,50,100这样&amp;nbsp;的值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了常见的随机梯度下降，还有不少改进的方法，如Momentum，Adagrad等等，有兴趣的可以看看http://cs231n.github.io/neural-networks-3/#update&amp;nbsp;，里面还有个动画，比较了不同方法的收敛速度的比较。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面的分析，我们把问题变成了怎么求loss对参数W的梯度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;求梯度有如下4种方法：&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.手工求解析解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如&amp;nbsp;f(x)=x^2，&amp;nbsp;df&lt;/span&gt;&lt;span&gt;=2*x。然后我们要求f(x)在x=1.5的值，代进去就2*1.5=3&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.数值解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用极限的定义：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcs8Ac8lsCcianTXooCkmOtInOP3P4fBf1mZHzeFoLCY80HZr5vkvJuzqA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.机器符号计算&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;让机器做符号运算，实现1的方法，但是机器如果优化的不好的话可能会有一些不必要的运算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如&amp;nbsp;x^2&amp;nbsp;+&amp;nbsp;2*x*y&amp;nbsp;+&amp;nbsp;y^2，直接对x求导数变成了&amp;nbsp;2*x&amp;nbsp;+&amp;nbsp;2*y，两次乘法一次加分，但是我们可以合并一下变成2*（x+y)，一次乘法一次加分。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.自动梯度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我会在稍微细讲一下，所以这里暂时跳过。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些方法的优缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.手工求解“数学”要求高，有可能水平不够求不对，但效率应该是能最优的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.没任何函数，甚至没有解析导数的情况下都能使用，缺点是计算量太大，而且只是近似解【因为极限的定义】，在某些特别不“连续”的地方可能误差较大。所以实际使用是很少，只是用它来验证其它方法是否正确。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.机器符号计算，前面说的，依赖于这个库的好坏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;实际的框架，如TensorFlow就是自动梯度，而Theano就是符号梯度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2.4&amp;nbsp;编程实战&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面的介绍，我们其实就可以实现一个经典的前馈(feed&amp;nbsp;forward)神经网络了，这种网络结构很简单，每一层的输入是前一层的输出。输入层没有输入，它就是原始的信号输入。而且上一层的所有神经元都会连接到下一层的所有神经元，就像我们刚才的例子，输入是784，中间层是15，那么就有785*15个连接【再加上每个中间节点有一个bias】。所以这种网络有时候也加做全连接的网络（full&amp;nbsp;connected)，用来和CNN这种不是全连接的网络有所区别，另外就是信号是从前往后传递，没有反馈，所以也叫前溃神经网络，这是为了和RNN这种有反馈的区别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，我们还没有讲怎么计算梯度，也就是损失函数相对于每一个参数的偏导数。在下一部分我们会详细讨论介绍，这里我们先把它当成一个黑盒的函数就好了。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.代码&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;我们这里学习一下Nielsen提供的代码。代码非常简洁，只有不到100行代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;https://github.com/mnielsen/neural-networks-and-deep-learning&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;git&amp;nbsp;clone&amp;nbsp;https://github.com/mnielsen/neural-networks-and-deep-learning.git&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2.运行&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;创建一个&amp;nbsp;test_network1.py，输入如下代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;import mnist_loader&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;import network&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;training_data, validation_data, test_data = mnist_loader.load_data_wrapper()&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;net = network.Network([784, 30, 10])&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;net.SGD(training_data, 30, 10, 3.0, test_data=test_data)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;保存后直接运行&amp;nbsp;Python&amp;nbsp;test_network1.py。这里我们让他进行了30次迭代，最终在测试数据上的准确率大概在95%左右（当然因为随机初始化参数不同，最终的结果可能有所不同）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;Epoch 0: 8250 / 10000&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Epoch 1: 8371 / 10000&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Epoch 2: 9300 / 10000&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;......&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Epoch 28: 9552 / 10000&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Epoch 29: 9555 / 10000&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;3.代码阅读&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Python代码很容易阅读，即使之前没有用过，稍微学习两天也就可以上手，而且大部分机器学习相关的代码不会用到太复杂的语言特性，基本就是一些数学的线性代数的运算。而Python的numpy这个库是用的最多的，后面阅读代码的时候我会把用到的函数做一些介绍，继续下面的阅读之前建议花十分钟阅读一下&lt;span&gt;&amp;nbsp;http://cs231n.github.io/python-numpy-tutorial/&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3.1&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;mnist_loader.load_data_wrapper函数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个函数用来读取mnist数据，数据是放在data/mnist.pkl.gz。首先这是个gzip的压缩文件，是Pickle工具序列化到磁盘的格式。不熟悉也没有关系，反正我们知道这个函数的返回值就行了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个函数返回三个对象，分别代表training_data，validation_data和test_data。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;training_data是一个50,000的list，然后其中的每一个元素是一个tuple。tuple的第一个元素是一个784维的numpy一维数组。第二个元素是10维的数组，也就是one-hot的表示方法——如果正确的答案是数字0，那么这个10维数组就是(1,&amp;nbsp;0,&amp;nbsp;0,&amp;nbsp;…)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而validation_data是一个10,000的list，每个元素也是一个tuple。tuple的第一个元素也是784维的numpy一维数组。第二个元素是一个0-9的数字，代表正确答案是那个数字。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;test_data的格式和validation_data一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么training_data要是这样的格式呢？因为这样的格式计算loss更方便一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3.2&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;Network类的构造函数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在调用net&amp;nbsp;=&amp;nbsp;network.Network([784,&amp;nbsp;30,&amp;nbsp;10])时就到了init函数。为了减少篇幅，代码里的注释我都去掉了，重要的地方我会根据自己的理解说明，但是有空还是值得阅读代码里的注释。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;class Network(object):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; def __init__(self, sizes):self.num_layers = len(sizes)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.sizes = sizes&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.biases = [np.random.randn(y, 1) for y in sizes[1:]]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.weights = [np.random.randn(y, x)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for x, y in zip(sizes[:-1], sizes[1:])]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如上面的参数，我们保存下来的self.num_layers=3，也就是3层的网络。每一层的神经元的个数保存到self.sizes里。接下来就是构造biases数组并随机初始化。因为输入层是没有参数的，所以是for&amp;nbsp;y&amp;nbsp;in&amp;nbsp;sizes[1:]，我们使用了numpy的random.randn生成正态分布的随机数用来作为参数的初始值。注意这里生成了2维的随机变量。回忆一下，如果我们有30个hidden&amp;nbsp;unit，那么bias的个数也是30，那就生成一个30维的1维数组就行了，为什么要是30*1的二维数组呢？其实用1维也可以，不过为了和weights一致，后面代码方便，就用二维数组了。另外weights也是一样的初始化方法，不过注意randn(y,x)而不是randn(x,y)。比如对于我们输入的[784,30,10]，weights分别是30*784和10*30的。当然其实weights矩阵转置一下也可以，就是计算矩阵乘法的时候也需要有一个转置。不同的文献可能有不同的记法，但是我们在实现代码的时候只需要随时注意矩阵的大小，检查矩阵乘法满足乘法的约束就行了，矩阵AB能相乘，必须满足的条件是Ｂ的列数等于Ａ的函数就行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于Nielsen的记法，矩阵的每一行就是一个神经元的784个参数，那么weights(30*784)&amp;nbsp;*&amp;nbsp;input(784*1)就得到30个hidden&amp;nbsp;unit的加权累加。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3.3&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;feedforward函数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给点输入a（784维），计算最终神经网络的输出（10维）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;def feedforward(self, a):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; """Return the output of the network if ``a`` is input."""for b, w in zip(self.biases, self.weights):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; a = sigmoid(np.dot(w, a)+b)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; return a&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码非常简单，这里用到了np.dot，也就是矩阵向量的乘法，此外这里有一个Sigmoid函数，这个函数的输入是numpy的ndarray，输出也是同样大小的数组，不过对于每个元素都进行了sigmoid的计算。用numpy的术语就是universal&amp;nbsp;function，很多文献里一般都叫elementwise的function。我觉得后面这个名字更直接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;#### Miscellaneous functionsdef sigmoid(z):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; """The sigmoid function."""return 1.0/(1.0+np.exp(-z))&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;def sigmoid_prime(z):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; """Derivative of the sigmoid function."""return sigmoid(z)*(1-sigmoid(z))&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面就是Sigmoid函数，另外也把sigmoid_prime，也就是Sigmoid的导数放在了一起【不记得的话看前面Sigmoid的导数的推导】。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3.4&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;SGD函数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个函数是训练的入口，比如我们之前的训练代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;net.SGD(training_data, 30, 10, 3.0, test_data=test_data)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;def SGD(self, training_data, epochs, mini_batch_size, eta,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; test_data=None):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;if test_data: n_test = len(test_data)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; n = len(training_data)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; for j in xrange(epochs):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; random.shuffle(training_data)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; mini_batches = [&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; training_data[k:k+mini_batch_size]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for k in xrange(0, n, mini_batch_size)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for mini_batch in mini_batches:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.update_mini_batch(mini_batch, eta)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if test_data:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; print "Epoch {0}: {1} / {2}".format(&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; j, self.evaluate(test_data), n_test)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; else:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; print "Epoch {0} complete".format(j)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一个参数就是training_data。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个参数就是epochs，也就是总共对训练数据迭代多少次，我们这里是30次迭代。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三个参数是batch大小，我们这里是10，最后一个参数是eta，也就是步长，这里是3.0。除了网络结构（比如总共多少个hidden&amp;nbsp;layer，每个hidder&amp;nbsp;layer多少个hidden&amp;nbsp;unit），另外一个非常重要的参数就是步长。前面我们也讨论过了，步长太小，收敛速度过慢，步长太大，可能不收敛。实际的情况是没有一个万能的准则，更多的是根据数据，不停的尝试合适的步长。如果发现收敛太慢，就适当调大，反之则调小。所以要训练好一个神经网络，还是有很多tricky的技巧，包括参数怎么初始化，激活函数怎么选择，比SGD更好的优化算法等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四个参数test_data是可选的，如果有（我们的例子是穿了进来的），则每次epoch之后都测试一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码的大致解释我用注释的形式嵌在代码里了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp;&lt;span&gt; &amp;nbsp; for j in xrange(epochs): ## 一共进行 epochs=30 轮迭代&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; random.shuffle(training_data) &amp;nbsp;## 训练数据随机打散&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; mini_batches = [&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; training_data[k:k+mini_batch_size]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for k in xrange(0, n, mini_batch_size)] ## 把50,000个训练数据分成5,000个batch&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个batch包含10个训练数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for mini_batch in mini_batches: ## 对于每个batch&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.update_mini_batch(mini_batch, eta) ## 使用梯度下降更新参数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if test_data: ## 如果提供了测试数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; print "Epoch {0}: {1} / {2}".format(&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; j, self.evaluate(test_data), n_test) ## 评价在测试数据上的准确率&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; else:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; print "Epoch {0} complete".format(j)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面是evaluate函数：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;def evaluate(self, test_data):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; test_results = [(np.argmax(self.feedforward(x)), y)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (x, y) in test_data]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; return sum(int(x == y) for (x, y) in test_results)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于test_data里的每一组(x,y)，y是0-9之间的正确答案。而self.feedforward(x)返回的是10维的数组，我们选择得分最高的那个值作为模型的预测结果np.argmax就是返回最大值的下标。比如x=[0.3,&amp;nbsp;0.6,&amp;nbsp;0.1,&amp;nbsp;0,&amp;nbsp;….]，那么argmax(x)&amp;nbsp;=&amp;nbsp;1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此test_results这个列表的每一个元素是一个tuple，tuple的第一个是模型预测的数字，而第二个是正确答案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以最后一行返回的是模型预测正确的个数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3.5&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;update_mini_batch函数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;def update_mini_batch(self, mini_batch, eta):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;nabla_b = [np.zeros(b.shape) for b in self.biases]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; nabla_w = [np.zeros(w.shape) for w in self.weights]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; for x, y in mini_batch:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; delta_nabla_b, delta_nabla_w = self.backprop(x, y)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nabla_b = [nb+dnb for nb, dnb in zip(nabla_b, delta_nabla_b)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nabla_w = [nw+dnw for nw, dnw in zip(nabla_w, delta_nabla_w)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; self.weights = [w-(eta/len(mini_batch))*nw&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for w, nw in zip(self.weights, nabla_w)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; self.biases = [b-(eta/len(mini_batch))*nb&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;for b, nb in zip(self.biases, nabla_b)]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的输入参数是mini_batch【size=10的tuple(x,y)】和eta【3.0】。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;def update_mini_batch(self, mini_batch, eta):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;nabla_b = [np.zeros(b.shape) for b in self.biases]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; ## 回忆一下__init__，biases是一个列表，包含两个矩阵，分别是30*1和10*1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; ## 我们先构造一个和self.biases一样大小的列表，用来存放累加的梯度（偏导数）&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; nabla_w = [np.zeros(w.shape) for w in self.weights]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; ## 同上， weights包含两个矩阵，大小分别是30*784和10*30&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; for x, y in mini_batch:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; delta_nabla_b, delta_nabla_w = self.backprop(x, y)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;## 对于一个训练数据(x,y)计算loss相对于所有参数的偏导数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ## 因此delta_nabla_b和self.biases， nabla_b是一样大小(shape)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ## 同样delta_nabla_w和self.weights,nabla_w一样大小&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nabla_b = [nb+dnb for nb, dnb in zip(nabla_b, delta_nabla_b)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ## 把bias的梯度累加到nabla_b里&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nabla_w = [nw+dnw for nw, dnw in zip(nabla_w, delta_nabla_w)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ## 把weight的梯度累加到nable_w里&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; self.weights = [w-(eta/len(mini_batch))*nw&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for w, nw in zip(self.weights, nabla_w)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;## 使用这个batch的梯度和eta（步长）更新参数weights&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; self.biases = [b-(eta/len(mini_batch))*nb&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;for b, nb in zip(self.biases, nabla_b)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ## 更新biases&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ## 这里更新参数是除了batch的大小（10），有的人实现时不除，其实没有什么区别，因为超参数eta会有所不同，如果不除，那么eta相当于是0.3(在eta那里就除了batch的大小了）。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3.6&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;backprop函数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个函数就是求loss相对于所有参数的偏导数，这里先不仔细讲解，等下次我们学习梯度的求解方法我们再回来讨论，这里可以先了解一下这个函数的输入和输出，把它当成一个黑盒就行，其实它的代码也很少，但是如果不知道梯度的公式，也很难明白。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;def backprop(self, x, y):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;nabla_b = [np.zeros(b.shape) for b in self.biases]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; nabla_w = [np.zeros(w.shape) for w in self.weights]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; # feedforwardactivation = x&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; activations = [x] # list to store all the activations, layer by layerzs = [] # list to store all the z vectors, layer by layerfor b, w in zip(self.biases, self.weights):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; z = np.dot(w, activation)+b&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; zs.append(z)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; activation = sigmoid(z)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; activations.append(activation)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; # backward passdelta = self.cost_derivative(activations[-1], y) * \&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sigmoid_prime(zs[-1])&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; nabla_b[-1] = delta&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; nabla_w[-1] = np.dot(delta, activations[-2].transpose())&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;for l in xrange(2, self.num_layers):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; z = zs[-l]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sp = sigmoid_prime(z)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; delta = np.dot(self.weights[-l+1].transpose(), delta) * sp&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nabla_b[-l] = delta&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nabla_w[-l] = np.dot(delta, activations[-l-1].transpose())&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; return (nabla_b, nabla_w)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的输入就是一个训练样本(x,y)分别是784*1和10*1。输出就是和self.biases,self.weights一样大小的列表，然后列表中的每一个数组的大小也是一样。具体到上面的例子，输出nabla_b包含两个矩阵，大小分别是30*1和10*1；nabla_w也包含两个矩阵，大小分别是30*784和10*30。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;未完待续&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;作者简介：&lt;/strong&gt;李理，目前就职于环信，即时通讯云平台和全媒体智能客服平台，在环信从事智能客服和智能机器人相关工作，致力于用深度学习来提高智能机器人的性能。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;责编：&lt;/strong&gt;周建丁（zhoujd@csdn.net）&lt;/p&gt;&lt;p&gt;更多详细内容，请持续关注MDCC大会官网， 9 月 4 日零点前，MDCC 大会门票处于 6.8 折优惠票价阶段，五人以上团购更有特惠，限量供应（阅读原文获取票务详情，欲购从速！）&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;</description>
      <pubDate>Thu, 08 Sep 2016 19:59:01 +0800</pubDate>
    </item>
    <item>
      <title>浏览器存储及使用</title>
      <link>http://www.iwgc.cn/link/2613607</link>
      <description>&lt;p&gt;&lt;span&gt;伴随着WEB的发展，浏览器的存储方式及技术不断的发生更改，从刚开始的Cookie，到localStorage，sessionStorage，再到IndexedDB，再到现在的Web SQL，作为一名合格的前端开发，当然需要对这些技术了如指掌并熟练掌握，本文将比较全面的介绍常见的浏览器存储以及其使用。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsqrj7ia5m00FiaXJshkecaPqeGGJzytz0dO8CXl6utlia0B5FEecRQwSsQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;1&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;Cookie&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cookie是一个用户通过浏览器浏览网站产出的信息的票根，Cookies通常被用来标示一个网站用户的浏览经历，它可能包含这个用户的个人偏好或访问这个网站的一些输入信息。用户可以自己随意操作他们浏览器中的Cookie。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cookies可以通过服务端使用Set-Cookie Http header来设置和修改，当然也可以使用javascript的document.cookie去操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;浏览器兼容性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcs9wDhGRV7jocgiaQ8iaOSLo0Bglu6ceeHiblEbny5PlRlfBocicR8lKk5aA/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细请参考：&lt;span&gt;http://caniuse.com/#search=cookie&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;在浏览器中操作如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;//读取网站下所有的cookie信息，获取的结果是一个以分号;作为分割的一个字符串&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var allCookies = document.cookie;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//例如：在百度首页，获取的如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// "BAIDUID=B32F2BF6BCB66D5559E199F5B1908F4C:FG=1; PSTM=1444711125; BIDUPSID=9DE77BD4B191F421CA54DB11C954067A; ispeed_lsm=0; MCITY=-289%3A; BDSFRCVID=hWtsJeC62Ag8XZc4Nvqo2MixJD2vkWoTH6aoB7vKuwGS_LREoJS6EG0PtvlQpYD-KiV2ogKK0eOTHvvP; H_BDCLCKID_SF=JbADoDD-JCvbfP0kKtr_MJQH-UnLq-vUbT7Z0l8KtqjJbMnL-TOF5R_eD4c0hUTRtjcW-b7mWIQHDp_65xRh5U-9BPvN04RZLbc4KKJxbPQSVtJXQKcvMq5XhUJiB5O-Ban7LtQxfJOKHICRe5-ajxK; BD_CK_SAM=1; locale=zh; BD_HOME=0; H_PS_PSSID=1455_18241_18559_17000_15227_11651; BD_UPN=123253"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//往原来的已经存在的cookie中加入新的cookie&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;document.cookie ="test=yui";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//当然也可以在后面加上可选择的选项键值对，例如domain，以及其他path，expires&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;document.cookie="test=yui;domain=.baidu.com"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//删除cookie，就是让这个cookie值得expires过，就是设置这个expires为0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;document.cookie="test=yui;domain=.baidu.com;expires=0");&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;需要注意的地方：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1) 通过上面的代码，可以看到document.cookie是个可访问的属性，但是它有内置的setter和getter的function，而不是一个简单的字符串数据，你的get和set都会调用这些原生内置的函数；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2) Cookie支持跨域，可以通过在根域名设置cookie，共享多个子域名的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;Cookie的Chrome浏览器实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cookie解析：&lt;span&gt;https://code.google.com/p/chromium/codesearch#chromium/src/net/cookies/parsed_cookie.h&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;2&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;Web Storage&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Web Storage有两种机制，分别为sessionStorage和localStorage。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage是一种半持久化的本地存储（会话级别的存储），而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两个对象，对外的方法主要有：setItem、getItem，以键值对的形式存储和读取，key按照索引获取当前存储的key值，找不到时返回null，length属性代表当前存储的key value对数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;浏览器兼容性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsfhAicBQ7ZRYMZg5E5cJbVC5AH5tEPib4W0GgeLeO3oWLn7c3k0liaia7kQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细请参考：&lt;span&gt;http://caniuse.com/#search=localstorage&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;代码示例（&lt;span&gt;以localStorage为例&lt;/span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;var username = 'helloworld';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var storageUsername;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var randomArr = [Math.random()，Math.random()，Math.random()，Math.random()];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var storageRandomArr;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//storage username，key值区分大小写，存入的内容为这个变量调用toString方法的结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage.setItem("username"，username);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//获取&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;storageUserName &amp;nbsp;= localstorage.getItem("username");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//"helloworld"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//删除&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage.removeItem("username");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;storageUserName &amp;nbsp;= &amp;nbsp;localstorage.getItem("username");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// null&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//存储对象时，可以先调用JSON.stringify方法，然后取出的时候再调用JSON.parse方法获取结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage.setItem("randomarr"，JSON.stringify(randomArrr));&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;storageRandomArr = JSON.parse(localStorage.getItem("randomarr"));&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Object.prototype.toString.call(storageRandomArr);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// "object Array"&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;IndexDB&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IndexedDB是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的API。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IndexedDB分别为同步和异步访问提供了单独的API，异步API方法调用完后会立即返回，而不会阻塞调用线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要异步访问数据库，要调用Window对象IndexedDB属性的open()方法。该方法返回一个IDBRequest对象(IDBOpenDBRequest)；异步操作通过在IDBRequest对象上触发事件来和调用程序进行通信。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IndexDb是NoSQL数据库，是一种支持事务的浏览器数据库，基本操作就是，打开数据库，增删改查各种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;浏览器兼容性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsvUJfEKLzFAOmm3rGuAw1wibJQteEx4JSOm38d38JLnwxClkN39iaDVrg/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细请参考：&lt;span&gt;http://caniuse.com/#search=IndexDB&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;代码示例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1) 打开数据库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;//处理浏览器兼容性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//如果该数据库MyDatabase不存在，则会被创建；如果已经存在，则被打开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open("MyDatabase");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//打开数据库失败的回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; console.log("failure");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//代开数据成功的回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onsuccess = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; console.log("success");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2) 初始化数据库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;var dbName = "MyDatabase";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var dbVersion = 2;//整数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// open函数接受的第二个参数，代表数据的版本，当打开的版本号比当前的版本号大时，会触发onupgradeneeded这个回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open(dbName，dbVersion);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var studentsData = [{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"001"，name:"xiaoming"，email:0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}，{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"002"，name:"xiaoxiang"，email:1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var tableName = 'students';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //错误处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onupgradeneeded = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var db = event.target.result;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //创建表，以id字段作为主键来确保唯一，使用keyPath表示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var objectStore = db.createObjectStore(tableName， { keyPath: "id" });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //给表添加索引&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore.createIndex("name"，"name"，{unique:false});//非unique索引&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore.createIndex("email"，"email"，{unique:true});//email字段作为unique索引&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; for(var i in studentsData){&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //插入数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; objectStore.add(studentsData[i]);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; console.log("---init db success---");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3) 使用事务添加、删除数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;transaction()方法接受两个参数并返回一个事务对象。第一个参数是事务希望跨越的对象存储空间的列表，即数据库中的表名称。如果你希望事务能够跨越所有的对象存储空间你可以传入一个空数组。第二个参数如果你没有为第二个参数指定任何内容，默认只读。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsB6xPTUvRTb1oqaiaOIvTUUE7tKJtXvojRHsw51seYjMDtC2glBonZOA/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;插入学生003，004，005&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;var dbName = "MyDatabase";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open(dbName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var addData = [{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"003"，name:"xiaofang1"，email:"3@qq.com"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}，{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"004"，name:"xiaofang2"，email:"4@qq.com"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}，{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"005"，name:"xiaofang3"，email:"5@qq.com"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var tableName = 'students';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//打开数据库失败的回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; console.log("open indexDb database failure");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//代开数据成功的回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onsuccess = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var db = event.target.result;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var transaction = db.transaction([tableName]，'readwrite');&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var objectStore;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var i;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //事务主要有三个回调，error，abort，success&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.onerror = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //处理错误&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(event);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.onbort = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //事务中断处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.oncomplete = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("添加数据成功");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore &amp;nbsp;= transaction.objectStore(tableName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; for(i &amp;nbsp;in addData){&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var request = objectStore.add(addData[i]);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; request.onsuccess = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("add one success");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;删除001学生&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;var dbName = "MyDatabase";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open(dbName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var db;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var tableName = 'students';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onsuccess &amp;nbsp;= function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var objectStore;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var transaction;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; db = &amp;nbsp;event.target.result;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction= db.transaction([tableName]，'readwrite');&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.onerror = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //处理错误&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("error when delete 001 "+ event.target.errorCode);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.onbort = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //事务中断处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.oncomplete = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("删除学生001成功");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore = transaction.objectStore(tableName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore.delete("001");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4) 使用索引查找数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要调用IDBObjectStore示例对象的index方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;var dbName = "MyDatabase";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open(dbName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var db;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var tableName = 'students';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onsuccess &amp;nbsp;= function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var index;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var objectStore;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; db = &amp;nbsp;event.target.result;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore = db.transaction([tableName]).objectStore(tableName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //根据索引字段email朝找3@qq.com的学生&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; index = objectStore.index("email").get("3@qq.com");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; index.onsuccess = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(event.target.result);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; };&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; index.onerror = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("error when find &amp;nbsp;by index "+ event.target.errorCode);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;indexDb还有游标查找功能，限于篇幅，就不展开介绍了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;4&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;WebSql&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Web SQL Database API实际上未包含在HTML 5规范之中，它是一个独立的规范，它引入了一套使用SQL操作客户端数据库的API，这些API有同步的，也有异步的，一般情况下，都会使用异步API。它的核心方法有三个：openDatabase，transaction和executeSql。这些API已经被广泛的实现在了不同的浏览器里，尤其是手机端浏览器。虽然W3C官方在2011年11月声明已经不再维护Web SQL Database规范，但由于其广泛的实现程度，了解这些API对Web开发还是非常有必要的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;浏览器兼容性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcscz5ymq3AY17tibvg7pM2oWhzpn8c0vsuOdUic5w3gY6HuuycGag2FibdQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详情请参考：&lt;span&gt;http://caniuse.com/#search=WebSql&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;代码示例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;var db;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var info = {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; dbName :"MyDataBase"，//数据库名称&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; dbVersion:"0.1"，//版本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; dbDisplayName:"测试数据库"，//显示名称&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; dbEstimatedSize:10*1024*1024 //数据库大小，单位字节&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db = window.openDatabase(info.dbName，info.dbVersion，info.dbDisplayName，info.dbEstimatedSize);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//初始化students表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db.transaction(function (trans) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //执行Sql，如果students表不存在，则创建改表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; trans.executeSql("create table if not exists students(id unique，name text null，email text null)"，[]， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("init success");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("error happen");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//插入数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db.transaction(function (trans) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; trans.executeSql("insert into students(name，email) values(?，?)"，['xiaoming'，'1@qq.com']， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("insert ok 1");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(arguments);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; trans.executeSql("insert into students(name，email) values(?，?)"，['xiaohong'，'2@qq.com']，function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("insert ok 2");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(arguments);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//删除数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db.transaction(function (trans) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;trans.executeSql("delete from students where name = ? "，['xiaohong']， function (trans，result) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.log("delete success");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;}， function (trans，message) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.log("error happen");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;});&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//查询数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db.transaction(function (trans) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; trans.executeSql("select * from students"，[]， function (trans，result) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("总共查询到 "+result.rows.length+" 条数据");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }， function (trans，message) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("error happen");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;5&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;其他&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;Application Cache&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Application Cache翻译成中文为应用程序缓存，是html5中为实现离线浏览所提供的API。结合Manifest文件使用，使用编程方式，更新浏览器缓存内容。主要调用update与swapCache去更新浏览缓存，目前该技术已经被最新的规范所废弃，转而使用了Service Workers。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;Service Workers&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个service worker是一段运行在浏览器后台进程里的脚本，它独立于当前页面，提供了一些不需要与web页面交互的功能，即那种在网页背后悄悄执行的能力。在将来，基于它可以实现消息推送，静默更新等服务，但是目前它首先要具备的功能是拦截和处理网络请求，包括可编程的响应缓存管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;6&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;小结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前Cookie的兼容性最好，使用的最广泛，但有被滥用的趋势。Web Storage兼容比较好，除了老板的IE 6，7不支持外，其他主流浏览器都已经支持了，使用起来也方便简单，适合存储键值对数据。WebSql由于未在HTML5规范中，前景堪忧，适当了解下。IndexDb目前来看，兼容性不太好，但是前景很好，目前由w3c在推广，相信在以后应该有个大爆发(个人看法)。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Application Cache目前已经被废弃，Service Workers目前属于起步阶段，感觉离实用还需要时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;参考链接&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;caniuse：http://caniuse.com/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Cookie：https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;谷歌开发者中心文档：https://developer.chrome.com/devtools/docs/resource-panel#inspecting-page-resources&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Mozilia 开发者中心：https://developer.mozilla.org/en-US/docs/Web&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ServiceWorkers：http://www.html5rocks.com/en/tutorials/service-worker/introduction/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;声明：&lt;/strong&gt;本文为CSDN原创投稿文章，未经许可，禁止任何形式的转载。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;作者：&lt;/strong&gt;叶文兵，MaxLeap UX组开发人员，负责公司主要项目前端开发工作，逐渐往Node.js全栈方向发展。本科毕业于安徽师范大学，入坑前端开发近3年。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;责编：&lt;/strong&gt;钱曙光，关注架构和算法领域，寻求报道或者投稿请发邮件qianshg@csdn.net，另有「CSDN 高级架构师群」，内有诸多知名互联网公司的大牛架构师，欢迎架构师加微信qshuguang2008申请入群，备注姓名+公司+职位。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016年9月22日-23日，SDCC 2016大数据技术&amp;amp;架构实战峰会将在杭州举行，两场峰会大牛讲师来自阿里、京东、苏宁、唯品会、美团点评、游族、饿了么、有赞、Echo等知名互联网公司，共同探讨海量数据下的应用监控系统建设、异常检测的算法和实现、大数据基础架构实践、敏捷型数据平台的构建及应用、音频分析的机器学习算法应用，以及高可用/高并发/高性能系统架构设计、电商架构、分布式架构等话题与技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9月4日24点前仍处于最低六折优惠票价阶段，单场峰会（含餐）门票只需499元，5人以上团购或者购买两场峰会通票更有特惠，限时折扣，预购从速。（票务详情http://bss.csdn.net/m/topic/sdcc_invite/hangzhou#goupiaoxinxi）。&lt;/span&gt;&lt;/p&gt;</description>
      <pubDate>Thu, 08 Sep 2016 19:59:01 +0800</pubDate>
    </item>
    <item>
      <title>聚类分析总结 &amp;amp; 实战解析</title>
      <link>http://www.iwgc.cn/link/2595352</link>
      <description>&lt;p&gt;聚类分析是没有给定划分类别的情况下，根据样本相似度进行样本分组的一种方法，是一种非监督的学习算法。聚类的输入是一组未被标记的样本，聚类根据数据自身的距离或相似度划分为若干组，划分的原则是组内距离最小化而组间距离最大化，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWuiaBLCSw4ibib2eUKU0vquX5hdYVXTecxZPPSpgX6eMupEJp7SquFYm76sQ9iawIgQdT33ox7JuFYjw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;常见的聚类分析算法如下：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;K-Means：&lt;/strong&gt; K-均值聚类也称为快速聚类法，在最小化误差函数的基础上将数据划分为预定的类数K。该算法原理简单并便于处理大量数据。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;K-中心点：&lt;/strong&gt;K-均值算法对孤立点的敏感性，K-中心点算法不采用簇中对象的平均值作为簇中心，而选用簇中离平均值最近的对象作为簇中心。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;系统聚类：&lt;/strong&gt;也称为层次聚类，分类的单位由高到低呈树形结构，且所处的位置越低，其所包含的对象就越少，但这些对象间的共同特征越多。该聚类方法只适合在小数据量的时候使用，数据量大的时候速度会非常慢。&lt;/p&gt;&lt;p&gt;下面我们详细介绍K-Means聚类算法。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;K-Means聚类算法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;K-Means算法是典型的基于距离的非层次聚类算法，在最小化误差函数的基础上将数据划分为预定的类数K，采用距离作为相似性的评价指标，即认为两个对象的距离越近，其相似度就越大。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;算法实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;选择K个点作为初始质心&lt;/p&gt;&lt;p&gt;&lt;strong&gt;repeat&lt;/strong&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2"&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;将每个点指派到最近的质心，形成K个簇&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;重新计算每个簇的质心&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;until 簇不发生变化或达到最大迭代次数&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;K如何确定&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;与层次聚类结合，经常会产生较好的聚类结果的一个有趣策略是，首先采用层次凝聚算法决定结果粗的数目，并找到一个初始聚类，然后用迭代重定位来改进该聚类。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;初始质心的选取&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;常见的方法是随机的选取初始质心，但是这样簇的质量常常很差。&lt;/p&gt;&lt;p&gt;(1)多次运行，每次使用一组不同的随机初始质心，然后选取具有最小SSE(误差的平方和)的簇集。这种策略简单，但是效果可能不好，这取决于数据集和寻找的簇的个数。&lt;/p&gt;&lt;p&gt;(2)取一个样本，并使用层次聚类技术对它聚类。从层次聚类中提取K个簇，并用这些簇的质心作为初始质心。该方法通常很有效，但仅对下列情况有效：样本相对较小;K相对于样本大小较小。&lt;/p&gt;&lt;p&gt;(3)取所有点的质心作为第一个点。然后，对于每个后继初始质心，选择离已经选取过的初始质心最远的点。使用这种方法，确保了选择的初始质心不仅是随机的，而且是散开的。但是，这种方法可能选中离群点。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;距离的度量&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;常用的距离度量方法包括：欧几里得距离和余弦相似度。欧几里得距离度量会受指标不同单位刻度的影响，所以一般需要先进行标准化，同时距离越大，个体间差异越大;空间向量余弦夹角的相似度度量不会受指标刻度的影响，余弦值落于区间[-1,1]，值越大，差异越小。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;质心的计算&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于距离度量不管是采用欧式距离还是采用余弦相似度，簇的质心都是其均值。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;算法停止条件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;一般是目标函数达到最优或者达到最大的迭代次数即可终止。对于不同的距离度量，目标函数往往不同。当采用欧式距离时，目标函数一般为最小化对象到其簇质心的距离的平方和;当采用余弦相似度时，目标函数一般为最大化对象到其簇质心的余弦相似度和。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;空聚类的处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果所有的点在指派步骤都未分配到某个簇，就会得到空簇。如果这种情况发生，则需要某种策略来选择一个替补质心，否则的话，平方误差将会偏大。&lt;/p&gt;&lt;p&gt;(1)选择一个距离当前任何质心最远的点。这将消除当前对总平方误差影响最大的点。&lt;/p&gt;&lt;p&gt;(2)从具有最大SSE的簇中选择一个替补的质心，这将分裂簇并降低聚类的总SSE。如果有多个空簇，则该过程重复多次。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;适用范围及缺陷&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;K-Menas算法试图找到使平方误差准则函数最小的簇。当潜在的簇形状是凸面的，簇与簇之间区别较明显，且簇大小相近时，其聚类结果较理想。对于处理大数据集合，该算法非常高效，且伸缩性较好。&lt;/p&gt;&lt;p&gt;但该算法除了要事先确定簇数K和对初始聚类中心敏感外，经常以局部最优结束，同时对“噪声”和孤立点敏感，并且该方法不适于发现非凸面形状的簇或大小差别很大的簇。&lt;/p&gt;&lt;p&gt;克服缺点的方法：使用尽量多的数据;使用中位数代替均值来克服outlier的问题。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;实例解析&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWuiaBLCSw4ibib2eUKU0vquX5NaRbdGwPRGXhA9UDkXCeII9jq8mHsPVXYjLZqDcec56ugQ9BwXlgPw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;下面我们用TSNE(高维数据可视化工具)对聚类结果进行可视化&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWuiaBLCSw4ibib2eUKU0vquX52Tt9ianxAoITPM2oSaKunibM0gNMeOyjgr70UzMQHPTC0D3fRqIm8sEQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;聚类效果图如下：&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWuiaBLCSw4ibib2eUKU0vquX5fj0KEZibRcH502JsuKokHW5HibWW5hHkbkz821zCicshV6HB7s0hbPfKA/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;下面我们用PCA降维后，对聚类结果进行可视化&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWuiaBLCSw4ibib2eUKU0vquX5akLVMf1dbXSVLpxJbryqasFjLicZ5wyZiayu3licq7uqCXGia0T0xlQZyw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;聚类效果图如下：&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWuiaBLCSw4ibib2eUKU0vquX5UcaYs8hbzl3uYiahtNUD06rEKic2hn7bpMsRkuycbLFdCK7RoZhZYsEw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;Python主要的聚类分析算法总结&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在scikit-learn中实现的聚类算法主要包括K-Means、层次聚类、FCM、神经网络聚类，其主要相关函数如下：&lt;/p&gt;&lt;ul class=" list-paddingleft-2"&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;KMeans: &lt;/strong&gt;K均值聚类;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;AffinityPropagation:&lt;/strong&gt; 吸引力传播聚类，2007年提出，几乎优于所有其他方法，不需要指定聚类数K，但运行效率较低;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;MeanShift&lt;/strong&gt;：均值漂移聚类算法;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;SpectralClustering&lt;/strong&gt;：谱聚类，具有效果比KMeans好，速度比KMeans快等特点;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;AgglomerativeClustering&lt;/strong&gt;：层次聚类，给出一棵聚类层次树;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;DBSCAN&lt;/strong&gt;：具有噪音的基于密度的聚类方法;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;BIRCH&lt;/strong&gt;：综合的层次聚类算法，可以处理大规模数据的聚类。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些方法的使用大同小异，基本都是先用对应的函数建立模型，然后用fit()方法来训练模型，训练好之后，就可以用labels_属性得到样本数据的标签，或者用predict()方法预测新样本的标签。&lt;/p&gt;</description>
      <pubDate>Wed, 07 Sep 2016 17:08:35 +0800</pubDate>
    </item>
    <item>
      <title>参加年度开发者大调查 Macbook Air等你来拿</title>
      <link>http://www.iwgc.cn/link/2595353</link>
      <description>&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;大家的月薪是多少？在近一年增长幅度是多少？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是否有跳槽计划？会选择什么类型的公司？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么开发语言使用最多？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在哪些Web开发工具使用的较多？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;......&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相信不少开发者都会有上述的疑惑或遇到类似的问题，为了勾勒出中国软件开发者当前最真实的生存状态和行业现状，2016年9月5日-10月10日CSDN发起“2016年中国软件开发者有奖大调查”活动，了解当下开发者的技能状态、开发工具配置、新技术应用等内容，希望能为软件开发者这一专属群体把脉。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本次大调查将于2019年9月5日到10月10日在CSDN官网进行&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;。&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;不论是否CSDN用户均可参与，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;CSDN还将从参与者中抽取幸运用户赠送丰厚大奖，回馈大家的辛苦付出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;奖项设置&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;特等奖两名 Macbook Air 11寸（1名），科大讯飞语音开发板（1名）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一等奖两名 Apple Watch Sport&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;二等奖四名 叮咚智能音箱&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;三等奖40名 IKBC键盘&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;四等奖100名 程序员2016年全年电子刊物&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;鼓励奖140名 程序员2016年10月刊一本&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;获奖规则&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所有奖项都将通过随机抽取的方式产生（使用CSDN ID登录参与调查，概率增加一倍哦），获奖名单将通过@CSDN 新浪官方微博以及CSDN微信公众号公布，请参与者随时关注我们的微博以及公众号，谢谢参与！（搜索微信号CSDNnews，即可关注CSDN微信）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAughm6icIMqoTcZVSeiclRaQLBoDjbKmSSJaeGvwwqgzAcXR9Hy2RKynbaMuwicaEGpTicwbF6yRSmiaBOw/0?wx_fmt=jpeg"/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;温馨提示&lt;/section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAughm6icIMqoTcZVSeiclRaQLB9VfLXIHQScmVbxGZuLuiaIibgPRsDcNDc9Wk5mibUK6ic3Yt6JiaArbpeEw/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;section&gt;填完本份调查问卷约需10~15分钟，无效问卷参与者不会纳入到抽奖环节中，谢谢合作。&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;【&lt;span&gt;点击原文，参与问答&lt;/span&gt;】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 07 Sep 2016 17:08:35 +0800</pubDate>
    </item>
    <item>
      <title>如何运用微服务来创建资产管理集成系统</title>
      <link>http://www.iwgc.cn/link/2595354</link>
      <description>&lt;p&gt;&lt;span&gt;在酒店行业，由于各类系统太过分散，进行整合势在必行。公司系统要与来自不同提供商的各类系统进行交互，这些系统的应用程序接口（API）也各不相同。此外，随着系统中录入的酒店客户增加，涉及的情况也越来越多，必须对其进行管理。由于这一行趋向互联化，资产管理系统（PMS）逐渐成为各大酒店的核心系统，而整合更是重中之重。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要想提供适用于酒店行业的软件解决方案，必须建立起与PMS供应商的双向集成系统。其中的挑战在于：我们需要大规模构建与管理这些联网的内容，并应对涉及多家酒店、多个PMS系统的情况。想要实现这些整合，有几种办法，本文将会介绍一个用于集成系统基础构建的简单架构设计方法。随着酒店发展，投资回报率（ROI）也会得以增加，而这种方法就使用到了微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;微服务是什么？&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;企业软件设计的思想领袖Martin Fowler曾为微服务下过一个全面的定义：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在过去几年中，“微服务架构”（Microservice Architecture）一词被广泛用于描述软件设计的某种特殊方式，即设计出一套独立的、可部署的服务。尽管这种架构风格尚无明确的定义，但在围绕着业务能力、自动化部署、终端智能、语言及数据的非集中控制方面，却有某些共同特征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本质来讲，微服务实际就是若干很小的软件组件，各个组件只专注于一件工作做好。不同于大型整体式的应用，使用微服务的应用各个部分可以拆开，每个部分只负责指定领域中每部分只需要在指定领域内专注管理一项功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正因如此，它们是各自独立且自治的。一项服务的变化也不会影响其他服务，不需要求其他部分一同进行变化。所以，当你慢慢壮大成熟时，不需要担心一旦有变化会影响到其他微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微服务的特点：小而专注、低耦合、高内聚&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;为何微服务如此强大?&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微服务架构能提供众多好处，主要有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;可扩展性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据不同的属性，单一的系统需要同多个PMS实体进行融合。假设需要与1000个属性进行融合，那么即使它们运行的是同一供应商提供的同一PMS系统，也需要对1000个不同的集成进行显示管理。为了添加更多的复杂性，这些实体可以是来自于不同的供应商。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当你加入更多的PMS实体和属性后，这一规模扩展得更大。如果你运行的是一个整体应用程序，那么你需要衡量所有事宜，因为它们是一个大整体。尤其是在访问量高峰期间，要想知道性能瓶颈在哪比较困难，而此时微服务会有更多的透明度。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果你利用的是微服务，那么在运行过程中是哪个服务出现了性能问题就一清二楚，而你也可以轻松地调整它们的容量（基础硬件），无需为正常运行的其他服务增加容量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤弹性设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;酒店PMS系统可能会出现故障或有性能问题，但不会影响系统的性能或正常运行时间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以按需部署微服务，想部署多少都可以。部署的越多，容错性以及对变化的管理手段就越多。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤独立技术栈（Tech Stack Independence）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;你可以有多个技术栈，每项服务也配备了最适合的技术栈。你的顾客资料一般会在存储关系型数据库内，而相关请求却会放在非关系型数据库（NoSQL）中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;此外，没有一个特定的技术栈是长期适用的，毕竟，技术栈有很多个。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤添加、变更、消除特性及重构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;微服务是一些很小的服务，通常只有几百行的代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于这些代码的内聚性使得它们简单易懂，也就是它们每个服务都运行在自己的进程中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;其中一个的变化对其他的服务不会有直接的影响。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;删除整个微服务系统也比较容易，基本没有什么风险。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤部署&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;酒店想要提供额外的服务，但必须在系统正常、无故障的情况下才能实现，比如正常将客户登记的信息以及更新状态的请求发送给PMS系统。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;回滚也比较容易。假使过程中出现错误，相对于在整体单一式的数据库中回滚整个系统，通过自己的数据库回滚恢复到上一个微服务的操作也比较简单。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;另外，对整体单一式的应用来说，部署下一个版本非常痛苦，即便只是新增一个单一特性，也需要对整个程序进行部署，而且一次性部署所有事宜也是很具有风险性的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：如果只是与一个PMS集成，微服务就是大材小用了，但如果在大规模集成的情况下，微服务架构的好处就体现出来了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;传统方法：整体单一式的应用程序&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，整体单一式的应用对开发新产品和开展新业务来说是比较有利的，因为它的操作简单。但在此期间，你仍需了解目前所在的领域，以及将它们集成整合到一起的方法。运用整体单一式的应用在开发和部署时更简单，也更方便模拟预订服务，以及在客户资料的微服务版块内实现顾客资料模块的设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过随着公司的发展，整体规模也会迅速增长；因此随着规模的增大，系统的运行也越来越困难，需要增加新的特性和代码。而随着系统内容的增加，系统逐渐会不受控制，从而不能很好地执行运维。由于整体单一式的应用通常既不内聚也不耦合，变更系统时需要更多的回归测试，以确保新特性不会破坏系统的其他部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，由于代码之间互相依赖，会增加故障诊断与调试的难度。在更新服务时，需要对共享的基础设施代码执行修改，如果中间出现bug就会出问题。而且，这么大的代码库也很难在短时间内让新晋的开发人员熟练掌握。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，它对部署也有影响：应用程序越大，启动的时间就越长。也许新增更多的服务，并对其进行复制十分简单，但要记得我们只有一个单一的数据库。而且不仅如此，系统的一些部分可能会需要使用更多内存，而其他的部分则需要更多的CPU。因此，如果无法分别权衡各个组件的需求时该怎么办？没错，只能增加更多的新服务器——但这种做法的成本极高。所以，一旦有一定规模的公司，都会想要将系统分解成微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;架构概况&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在我们要来解释一下采用微服务架构所带来的长期性效益。不过，我们先来了解下微服务架构的设计细节。最重要的一点就是分离：集成系统应互相独立。举例来说，你的核心系统独立于X物业内运行的物业管理系统，同时也独立于Y物业运行的系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要想实现这种分离需要在核心系统和所有物业管理集成系统之间使用一个连接器，即中间件。中间件由两个方面组成：消息队列和background worker。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可用于实现服务的例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消息队列：RabbitMQ，IronMQ等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;后台worker：IronWorker，AWS Lambda等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息队列为系统间提供异步通信。发送者系统（你的系统）发布了一个消息到队列中，之后消息就会留在那里，直到稍后有订阅过队列的后台worker来处理。之后，后台worker会负责处理这则消息（解析内容）并利用PMS API进行管理集成，同时将数据保存到了中间件的数据库内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：后台worker可以是像AWS Lambda的云服务，也可以是Java或Windows服务器内部开发的程序。下面我们将会详细对其介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;值得注意的是，消息队列遵循的是先进先出的原则（FIFO），因此处理队列中所有的消息都会按照它们输入的顺序。假设你有多个队列，发布到X队列的信息稍后会比Y队列中的信息优先处理。这一点在设计的时候需要考虑进去。不过，如果酒店的系统是PMS，那就不需要担心这些，因为它会在云或本地的系统中运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这项服务不仅仅是一个CRUD包装器，因为它还控制着与预订相关的所有生命周期事件。如果需要指定预订一间房、新增一位陪同客人或登记入住的话，就需要发送一个恰当的请求给同一worker。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在我们根据Martin的描述来逐条分析一下微服务主要的几个特征，以及我们的架构又是如何实现这些特征的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;围绕业务能力的组织&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在如何与PMS集成过程中，每个worker都负责实现一块逻辑。我们可以在一家资产产业的同一个PMS实例中接入多个worker，在另一家酒店添加与同一个PMS（相同运营商）相连的更多worker，也可以在其他产业中添加与其它PMS相连的其它worker。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，假如我们需要修改与某些API互动的方式，只需单独对其中一个worker进行新版部署即可，完全不会影响到其它worker。我们可以让一个worker处理预订事宜，让另一个处理顾客资料档案事宜；可以使用Linux的crontab来安排一些后台worker，按照指定日程来循环执行任务；令其它一些worker持续运行，并在收到消息时立即处理。其它后台worker也可以唤醒核心系统的API，以便插入或更新其自PMS那里收集到的新消息（比如从PMS获取或读取数据，将之载入核心系统）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Sam Newman所著的《构建微服务》一书中，他指出“基于较为小型的数据库工作的较小型团队生产率更高”——通过微服务就能实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不仅生产率的问题，将团队或个人从一个微服务切换到另一个（共享同一个数据库）也是可以的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而且由于长时间在同一个项目中工作的团队或个人可能会产生局限性，这种做法还能鼓励创新：让团队在产品与项目上互换，可能会造就数以千计的新点子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤自动化部署&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微服务的部署需要以自动化形式实现，原因为何？首先是因为微服务数量太多，如果手动部署，不但很容易出错，也很浪费时间。具体情况要取决于所拥有的微服务数量，而且每个服务必须分别、独立的发布。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意，这里说的是部署微服务的新版本，并不涉及新的worker实例——worker已经在运行中了，但需要部署新的代码版本。举例说明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;假设要集成1000家产业，其中有500家使用运营商1所提供的PMS（即PMS_1），另有500家使用运营商2所使用的PMS（即PMS_2）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;除了运营商之外，由于背景十分相似，这里各个PMS实例中的worker数量很可能也是差不多的，除非我们想要添加更多相同类型的worker。为了简单起见，我们假设每个PMS实例中有5个worker，一个负责预订，一个负责顾客档案等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于PMS_1的API与PMS_2的API不同，与PMS_1集成的预订服务其中的代码就和与PMS_2集成的预订服务代码不同。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在这1000家产业中，有5000个worker，其中：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: circle;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PMS_1有2500个，500个负责预订工作，500个负责顾客资料工作，500个X worker，500个Y worker，500个Z worker，与PMS_1集成，每家产业各一；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PMS_2有2500个，500个负责预订工作，500个负责顾客资料工作，500个X worker，500个Y worker，500个Z worker，与PMS_2集成，每家产业各一。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;假设我们对与PMS_1集成的预订服务做了代码修改，通过测试后准备发布。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;假设源代码数据库只有一个，各个微服务也使用了持续集成工具，现在需要将代码部署到500个worker上，也就是与PMS_1集成的500个预订服务worker。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，使用微服务的目的之一就是为了敏捷灵活，因此我们需要自动化。这就是持续集成与持续交付（CI与CD）大显身手的时候了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CI即需要开发人员一天数次将代码集成到共享数据库的开发实践，提交就会触发build，如果build失败就会向所有人发送警告。其中的关键在于，及早发现提交出现的问题（也即是代码的问题）。如果build成功，就会部署到应用服务器上，并触发持续交付（CD）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CD即确保上面build成功的内容可以快速部署到生产环境中的实践，首先将应用部署到与生产环境特性相同的staging环境中，再点击“部署”按钮即可将应用部署到生产环境中。这里最棒的是：由于只需点击一个按钮，这样实现时就无需打断软件工程师的工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可用于执行CI/CD的服务样例包括：Atlassian Bamboo、TeamCity、Jenkins等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，不要将持续交付与持续部署相混淆，本文不会深入讨论这个问题，不过PuppetLabs有一篇文章是讨论持续交付与持续部署的不同点的，值得一读。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还要注意：微服务在部署时比整体单一式的应用更安全，因此实现自动化也更容易。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤端点的智能化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后台运行的worker封装了与PMS集成的逻辑，如果需要变更逻辑，或者变更PMS的API，我们只需修改一个地方即可——但不是在主系统中（主系统需要与下游API的变更隔离）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，各个PMS都有自己的API，因此要将与各个API通讯的逻辑与核心系统相隔离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤语言与数据的分散控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个微服务都有自己的技术堆栈，因此我们可以运用技术异质性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，需要改善特定组件的性能时，选择能够实现需要性能的技术堆栈即可。新的服务并不依赖于旧的技术定义，而且会在适合的时候使用新的语言或技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;各个worker可使用不同的技术构建：worker 1使用Java语言，MySQL数据库，负责处理顾客资料；worker 2使用C#语言，NoSQL数据库，负责处理顾客留言。要记得：它们是彼此独立的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们需要考虑集成的问题，比如在实践中如何互相集成。你是否有计划要部署RESTful API来返回JSON，或者与XML对话的SOAP API呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在我们来深入探讨一下中间件的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤中间件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中间件将系统和我们与之交互的多个资产管理系统隔离开来，由消息队列与后台worker组成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中间件不应当保存状态：各个端点的系统，比如你的系统与PMS系统负责保存酒店、顾客资料、预订信息等相关的状态，而中间件只负责创建两个系统之间的映射。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因在于：我们不希望引入一个保存状态新组件，从而造成一致性问题。而且同一个事务存储在三个不同的系统——即酒店资产管理系统，中间件系统和核心应用中，如果出现bug就会很难集成。在这样的情况下，哪个系统保存的是真实的预订状态呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中间件必须为我们统一核心系统与PMS系统的内容提供方法，因此如果在核心系统中有新需求创建，但出于某些原因，比如离线、软件有bug、网络问题等，没能存入PMS，中间件就应当向用户发出警告，并提供重集成的方法。中间件必须为每条信息在队列中的位置，还有每个后台worker的状态提供清晰的可视化效果。让用户了解某条消息出错以及出错原因，并提供重试机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在中间件数据库的顶层要有一个缓存层，以便能更为迅速地访问常用对象，比如城市代码、信用卡类型等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;使用微服务所带来的挑战&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在构建任何软件时都会有挑战，特别是大规模的集成系统时。在《构建微服务》一书中，Newman提醒我们“在大规模实现中，出错在所难免”，在部署微服务时也是如此。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们要接受这一现实——无论硬盘、网络等等都会出错，处理多个独立服务的错误也非常困难。分布式与异步架构在部署和debug时都很难实现，我们需要查看分布在多个实例中的日志，查看分布式事务来了解为什么会出现奇怪的状态。如果在同步流程中出错，进行上一个状态的回退是很困难的。由于经常会并行工作，找到出错点也是很困难的，而且由于可能有竞争条件介入，也会难以管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;确保微服务大规模实现中的一致性是另一个挑战。想象一下，一个服务管理顾客资料，另一个管理预订服务。如果有新顾客第一次预订你的酒店，预订微服务会创建新的预订记录，而顾客资料微服务需要创建新的顾客资料。如果顾客资料出现bug，没能成功创建新的顾客资料呢？如果没能正确执行管理，最终就只剩一个不与任何顾客资料相关联的单独预订记录。在大规模的情况下，这种情况很难追踪与管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;异步分布式架构可能会导致其它问题：假设系统向事务队列发出特定类型的请求，导致worker崩溃，而且又添加了从同一个队列拉取消息的多个worker，来加快处理速度。第一个worker从队列拉取消息，然后挂掉了，请求超时锁定，原本的消息被丢回队列。然后第二个worker要从队列中拉取同一个消息，结果一样，也挂掉了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一个挑战在于，我们必须持续监控数百个服务的重新部署，从而导致有需求促发专门的DevOps资源或团队来管理如此数量巨大的服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当有许多远程调用的时候，由于是通过网络连接的，还需要考虑整体的系统性能。我们都知道，网络是不可靠的，可能会导致数据包延迟或丢包等等。此外，各个系统之间的消息也并非实时传达的：向消息发布一条消息之后，隔一阵子才能得到处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，通过微服务有效地实现版本控制也是很困难的，最终需要改变服务的接口。如何进行管理呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在各个架构中的处理方法都有所权衡，不但微服务中存在挑战，每种方法也存在挑战。管理多个PMS的大规模集成时，使用微服务的好处要远大于付出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;考虑到大规模部署的经济效益：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在微服务的部署中，一些比较成本如下：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在大规模部署中，100个不同的PMS集成可能需要100个服务器。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在单一整体式的方法中，这些服务器要持续运行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;而在微服务中，可以按需唤醒微服务，并在不需要的时候关闭。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用类似AWS Lambda或者IronMQ之类的云服务时，AWS所提供的按需供应系统可以让我们按照需求来应用，从而更有效地控制自己的花费。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长期使用的情况下，微服务更加划算，而且能够更接近实际地管理开销，减少浪费。从未有过如此节省的架构方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面要怎么做？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;告别整体单一式架构&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经常会有一个问题：“我的应用已经应用了整体单一式架构，是否需要从头重构，以便部署微服务架构呢？”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;答案是：不需要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以一点点地改动，最终告别单一整体式架构。这应当是一个递增式的方案，我们可以从中更深入地了解核心功能，以及它与其它核心功能的互动方式。对服务应有的状态，以及与其它服务的通讯方式要建立起认知，这是很关键的。采用“边学边干”的方式，逐步定义系统的哪个部分应当使用微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着系统规模的扩大，微服务数量增长，这一方法会让你更灵活、更有效也成本更低地扩展系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt; How To Build Your Property Management System Integration Using Microservices 作者： Rafael Neves，本文作者Rafael Neves是Alice公司的首席企业架构师。Alice公司是一家总部位于纽约的酒店领域技术创业公司，虽然隶属于资产管理领域，但也是微服务方面的入门优秀范例。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;译者：&lt;/strong&gt; 孙薇&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;责编：&lt;/strong&gt; 钱曙光，关注架构和算法领域，寻求报道或者投稿请发邮件qianshg@csdn.net，另有「CSDN 高级架构师群」，内有诸多知名互联网公司的大牛架构师，欢迎架构师加微信qshuguang2008申请入群，备注姓名+公司+职位。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016年9月22日-23日，SDCC 2016大数据技术&amp;amp;架构实战峰会将在杭州举行，两场峰会大牛讲师来自阿里、京东、苏宁、唯品会、美团点评、游族、饿了么、有赞、Echo等知名互联网公司，共同探讨海量数据下的应用监控系统建设、异常检测的算法和实现、大数据基础架构实践、敏捷型数据平台的构建及应用、音频分析的机器学习算法应用，以及高可用/高并发/高性能系统架构设计、电商架构、分布式架构等话题与技术。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9月4日24点前仍处于最低六折优惠票价阶段，单场峰会（含餐）门票只需499元，5人以上团购或者购买两场峰会通票更有特惠，限时折扣，预购从速。（阅读原文获取票务详情）。&lt;/span&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 07 Sep 2016 17:08:35 +0800</pubDate>
    </item>
    <item>
      <title>企业在数据库领域面临的五大挑战</title>
      <link>http://www.iwgc.cn/link/2580900</link>
      <description>&lt;p&gt;&lt;span&gt;大数据时代，数据已成为公司最有价值的资产之一，因此，设计、实现和维护好数据库，对公司是至关重要的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据IDC数据显示，在2015年到2017年间，数据库市场已由400亿美元增长到500亿美元。然而，企业只有高效管理这些数据，才能在新的应用和云计算领域立于不败之地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面让我们一起来看看当今企业在数据库领域面临的五大挑战：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;配置数据资产&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接近80%的开发者和IT专业人员认为，数据库资产配置是当前的主要瓶颈之一，开发人员需要更灵活地加快这一过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺乏专业的DBAs&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据的急速增长也对DBAs产生了更多的需求，市场上普遍缺乏熟练专业的DBAs，这也就意味着因为企业缺乏人才而导致一些项目被搁置，从而没有足够的IT基础设施来推动创新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;影响性能的因素有很多，比如数据库配置和数据库扩张。此外，糟糕的数据库设计、编码错误和额外的数据和用户都可能影响和放缓整体的数据库性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库扩展&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着公司业务发展，IT基础设施建设也应跟上来，并提前规划好未来的增长。而不是临时或随便添加多种版本的SQL服务器，这样，数据分配在不同的数据库服务器里，着实难以维护。这种缺乏战略规划的行为也很容易造成数据库性能低下，并且带来很大的安全风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;快速增长的数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务转换和数据的爆炸式增长使得企业很难高效地管理它们的数据存储和管理需求。虽然大部分企业的IT基础设施仍停留在以往建设水平，但也有许多企业正在迁移到云或者混合云上，把云作为当前数据管理的一种解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据的爆炸式增长，使得企业需要采取更具有战略性的方法来管理和维护好数据库。这对企业的快速壮大和扩张也至关重要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjXuhHf9WCBWMNzicyLwZNBVib5CHFBqtzgfgFXvxlzFaVO9qkvvNwbwdJBmgWnUH4IHdWOiczXEnqibow/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;</description>
      <pubDate>Tue, 06 Sep 2016 17:25:01 +0800</pubDate>
    </item>
  </channel>
</rss>
