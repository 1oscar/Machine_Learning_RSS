<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>CSDN大数据</title>
    <link>http://www.iwgc.cn/list/1933</link>
    <description>CSDN分享Hadoop、Spark、NoSQL/NewSQL、HBase、Impala、内存计算、流计算、机器学习和智能算法等相关大数据观点,提供云计算和大数据技术、平台、实践和产业信息等服务.</description>
    <item>
      <title>《程序员》：信息无障碍的发展和技术实践</title>
      <link>http://www.iwgc.cn/link/2613605</link>
      <description>&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;本文为《程序员》原创文章，未经允许不得转载，更多精彩请订阅2016年《程序员》&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“信息无障碍”起源于西方发达国家，译自“Accessibility”，指任何人在任何情况下都能平等、方便、无障碍地获取并利用信息。本文将从身体障碍和信息障碍、法规和标准、产品和技术实践，这三个方面介绍信息无障碍的发展和实践经验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当Tim Berners-Lee发明万维网时，他的美好愿景是Web for All，这意味着让所有人都能对Web加以利用，不论文化教育背景、能力、财力以及身体残疾。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在信息技术高速发展的今天，很多人没有网络都觉得没法生存，但是在这个星球上，数以亿计的人是被信息技术远远抛下的群体。他们是失明失聪的残障人士，或者是贫困农村的失学儿童，又或者是不会使用互联网的老年人。这就是所谓的信息障碍。信息无障碍是愿景，而信息障碍是需要面对的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;身体障碍 VS. 信息障碍&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“信息无障碍”经常被人们认为是为残障人士提供的某种特别服务或工具。这种想法无可厚非，毕竟，残障人士是信息障碍最大的受限群体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是让我们换一种方式思考，什么是障碍？前方的道路有条河流，没有轮渡也没有桥梁；或者是迷失在高速公路上，没有导航设备也没有清晰的路标。这些都是障碍，但这样的障碍是人类可以解决的，或者说是人为造成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信息障碍类似于此，人们总是可以找到通用的、辅助的解决方案，或许会有滞后，但必然会出现的。举两个例子，对于很多不了解无障碍技术的人来说，视障人士是不能使用电脑的，听障人士是不能使用电话的，实际上，帮助聋哑人士使用电话的TDD（Telecommunications Device for the Deaf）技术在20世纪60年代产生（国内电信行业由于时间周期、语言等原因，没有引进该技术）；帮助视障人士使用电脑的读屏软件在80年代就已出现；我们可以看到那些复杂的信息障碍一样也能被跨越。要强调的是，信息障碍不是某类人群的障碍，而是某类信息技术产品缺少人性化、通用性思维造成的，并且这类障碍是有方法解决的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp7iaL7h0X5hm99S6kvQ1Io6OXW3Fl3PYprOd49JhPicJJgMr6jTKR17t0w/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1 早期的TDD设备，语言形式通过文字和语音形式同时传输&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;法规 VS. 标准&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Tim Berners-Lee 1997年在W3C内部成立了WAI（Web Accessibility Initiative），负责开发Web无障碍相关标准，该组织在1999年完成了Web内容无障碍指南1.0（Web Content Accessibility Guidelines 1.0，WCAG 1.0）的开发，其后在2008年重新制定了WCAG 2.0，虽然WCAG以及2.0这个版本的制定主要针对Web内容，但它也确定了信息无障碍的四个基本原则：可感知性、可操作性、可理解性、鲁棒性，以及信息障碍可能覆盖的几类残障人群。在近二十年的时间里WAI围绕着WCAG开发了一系列相关规范，涉及用户代理、开发工具，以及语义标签。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美国1973年建立了《康复法案》，所有政府资助的项目，禁止对于残障人士的就业歧视。2000年前后，《康复法案》完善了补充法规 – Section 508，除了节选当时的WCAG 1.0（Web Content Accessibility Guidelines 1.0）以外，也对其它信息产品（Electronic and Information Technology）进行了无障碍实施定义，包括数字文档、闭路产品、沟通技术等，法规的建立进一步规范了美国国内的无障碍技术依据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;产品 VS. 技术实践&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美国作为信息产品、技术生产大国，对于信息无障碍的相关标准、法规、技术方法，甚至是投诉机制的完善，也促进了传统的IT企业和新兴互联网企业开始重视这个领域，并重新审视这个领域的价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IBM&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1999年，IBM开发了内部产品无障碍标准（Corporate Instruction 162，CI 162），该规定要求IBM自身的软件、硬件、Web应用，甚至是对内对外服务都应该具有无障碍特性及接口。2000年左右，IBM成立无障碍研究中心，隶属于研究院，专注于研究、开发残障人士使用IT技术，并且通过这类研究提高产品通用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp7B6Q5ficwBnoz85MibEuKyMRbZjiaflz8P0CAZEo0PAXk0eKnapugWhK6w/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2 IBM的Easy Web Browsing&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信息障碍的基本辅助手段之一是文字转语音技术（Text to Speech，TTS）和语音识别技术，IBM充分发挥自己在这些技术的强项，二十年前就有了通用性很强的语音识别软件——ViaVoice，功能上基本就是单机版的Siri；专门为视障用户使用辅助浏览工具的Home Page Reader，配备多种语言版本的TTS。IBM信息无障碍中心早期的产品——Easy Web Browsing是一个浏览插件，帮助有低视力（非全盲）、色盲、色弱、学习障碍等用户浏览网络，这款产品简单易用，运用范围很广。而aDesigner是IBM早期的网站无障碍评估工具，已经开源到Java社区，更名为ACTF。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Apple&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Apple的产品简单易用到极致，例如iPhone，虽然外形简单，但是内置的辅助功能和系统平台无缝衔接，辅助工具VoiceOver更是与系统应用完美结合，使得iPhone一直以来都能在残障群体里广受好评。其实，当iPhone刚刚推向市场时，由于完全抛弃了物理键盘，并且没有任何辅助技术接入，被视障群体诟病多年，直到iOS 3.0添加了辅助技术，并且完善了iOS开发的无障碍接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp76EDCXHrpaSvHAtjO3alLuvqP1HOtsItIGLd3PtnIbv1H8n6oJEziaWA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3 视障用户可以方便的使用iOS和Mac设备内置的VoiceOver&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随后，iOS不断添加通用性的平台应用，如FaceTime和Siri, 这些应用不仅让年青用户觉得很有乐趣，对于残障人士也很有益处，FaceTime的视觉形式交流可以让听障用户用手语交流，而Siri的引导式访问，能够快速启动平台应用，对于视障和肢体障碍用户帮助很大。除此以外，一些独特的内置功能、特性，也对残障人士极为友好，例如单声道音频，帮助单耳失聪或者重听的用户更好地使用音频声道。第三方软件，更可以帮助严重的自闭症患者学习、交流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Google&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;和传统的IT企业比起来，互联网企业的用户基数更为巨大，他们对于无障碍的重视也不仅仅停留在标准、法规上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Google作为互联网领军企业，产品已不单限于互联网，其主要产品都已经具有无障碍特性，或者增加了无障碍接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Android——众所周知的移动平台应用，和iOS一样，做了无障碍优化，并完善了开发无障碍的接口，很遗憾的是，国内很多手机厂商，把这个重要模块阉割了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp78pnrbdpwiafdZN2xRO5e3RXQXzibcvBtTOyd86gCT05ZSfyx9ibpA2eVA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4 包含多种类型字幕的YouTube视频，方便让视障人士和听障人士获取视频中的信息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;浏览器是和Web结合最紧密的用户代理，它和读屏软件一起帮助视障用户获取互联网信息，它对无障碍语义标签的支持，决定了视障用户获取信息的多少。Chrome浏览器对无障碍语义标签的支持一直都是最好的，不仅如此，它也扩展了其它形式的无障碍支持，比如丰富的快捷键、无障碍扩展、第三方无障碍测试工具。而Google旗下YouTube视频网站，通过字幕帮助听障人士获取信息，字幕的添加使用的是语音识别技术和字幕编辑软件结合完成，而语音识别的准确率则以Google积累深厚的大数据为基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Facebook&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Facebook是Web 2.0的先驱，它在信息无障碍的很大挑战是，大量数据、图片、文字由用户创造，在无障碍范畴里，图片只有添加了相应的替代文本，或者有意义的语义标签才能被辅助工具使用，让视障人士能够了解图片含义，但是Facebook并不能强行要求用户去为某个图片添加无障碍的语义标签和替代文本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaibSdrCGQnhXicdhlVDw2pp74s6oFVctzdibWgsjdkobEqCiawUI3R1gtFyYs08kGa1lIg6YRPTRPzmQ/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5 Facebook的iOS应用，可以自动识别图像内容，并朗读出来&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是Facebook并未放弃对信息无障碍的探索，2016年初，Facebook宣布通过人工智能技术帮助视障人士使用其应用，方法就是自动识别图像内容，为用户上传的图片添加替代文本，并将该文本朗读出来，帮助视障用户“看到”图片的内容，和Google的语音识别一样，图像的识别也是通过大数据完成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;编外&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到信息技术虽然高速发展，也一直在完善它的不足。现代技术的叠加、互相补充，让信息无障碍技术富有想象力和创造力，不仅帮助残障人士使用信息产品，让他们公平地获取信息，也帮助信息产品的通用性、人性化提升到新的高度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;作者：张昆，信息无障碍研究会首席专家。拥有近20年的信息无障碍理论及实践经验，曾任职IBM大中华区信息无障碍中心专家、W3C中国区信息无障碍事务负责人，参与了“2008年北京奥运会信息无障碍方案”、“W3C信息无障碍标准制定”等重大项目。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;移动端无障碍产品开发，是移动端产品的主要特性之一，常被开发者忽视，但是这样的特性却影响数以百万计的用户人群，那么应该如何打造移动端产品的无障碍呢？在MDCC 2016上，张昆将带来题为《移动端无障碍产品开发》的分享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更多精彩尽在MDCC 2016，详情请查看大会官网：http://mdcc.csdn.net/。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;2016 年 9 月 23-24 日，由 CSDN 和创新工场联合主办的“MDCC 2016 移动开发者大会• 中国”（Mobile Developer Conference China）将在北京•国家会议中心召开，来自iOS、Android、跨平台开发、产品设计、VR开发、移动直播、人工智能、物联网、硬件开发、信息无障碍10个领域的技术专家将分享他们在各自行业的真知灼见。大会门票8折优惠中，五人以上团购更特惠，限量供应（&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;获取票务详情，8折优惠，欲购从速！）&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;</description>
      <pubDate>Thu, 08 Sep 2016 19:59:01 +0800</pubDate>
    </item>
    <item>
      <title>李理：从Image Caption Generation理解深度学习（part II）</title>
      <link>http://www.iwgc.cn/link/2613606</link>
      <description>&lt;p&gt;&lt;span&gt;本系列文章面向程序员，希望通过Image&amp;nbsp;Caption&amp;nbsp;Generation，一个有意思的具体任务，深入浅出地介绍深度学习的知识，涉及到很多深度学习流行的模型，如CNN，RNN/LSTM，Attention等。本文为第二篇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者李理，MDCC&amp;nbsp;2016&amp;nbsp;移动开发者大会人工智能与机器人专场的出品人，邀请人工智能一线专家担任演讲嘉宾，从无人驾驶、智能机器人、智能应用开发实战等方面解读人工智能技术的内涵及其对移动开发工作的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;书接上文：李理：从Image&amp;nbsp;Caption&amp;nbsp;Generation理解深度学习（part&amp;nbsp;I）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;2. 机器学习基本概念和前馈神经网络&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;2.1&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;机器学习基本概念&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家可能平时都写过很多程序，写程序和机器学习的思路可能有一些不同。写程序时，我们是“上帝”，我们规定计算机的每一个步骤，第一步做什么第二步做什么，我们称之为算法。我们能够控制所有的情况，如果出了任何问题，肯定都是程序员的责任。而在机器学习的时候，我们只是“老师”。我们告诉学生（计算机）输入是什么，输出是什么，然后期望它能够学到和我们类似的知识。比如我们跟小孩说这是狗，那是猫，我们没有办法像上帝那样拿着“纳米手术刀”去操作人脑神&amp;nbsp;经元的连接方式。我们只能不断的给小孩“训练数据”，然后期望他能够学会什么是猫，即使我们觉得他“学会”了识别猫，我们也没有办法知道他是“怎么”学会&amp;nbsp;的，而且同样的训练过程可能换一个人就不好使。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;机器学习和人类的学习是类似的——我们也是给它训练数据，然后期望它能学会。我们会给机器建一个模型，从数学的角度来说一个模型就是一个函数，它的输入一般是一个向量【当然可以是二维的矩阵如图片或者三维的张量比如视频】，输出可以是有限的离散的标签如“猫”，“狗”，这类问题我们称之为分类；而如果输出&amp;nbsp;是连续的值比如用这个模型来预测气温，那么我们就称之为回归。其实人类的很多科学活动和日常生活，都是在“学习”模型和“应用”模型。比如开普勒通过观测&amp;nbsp;大量天文数据“归纳”出行星的运动规律。从本质上讲，智能就是从“过去”学习，然后根据“现在”来预测可能的将来并根据自己的目标选择有利于自己行为。只不过之前，似乎只有人类能够从数据中“学习”出规律，而人工智能的目标就是让机器也有类似的学习能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;模型用数学来说就是一个函数，我们人脑的函数由神经元的连接构成，它可能是一个很复杂的函数，我们现在还很难彻底研究清楚。神经网络就是试图通过计算机来&amp;nbsp;模拟和借鉴人脑这个模型，除了我们这里要讲的神经网络之外，机器学习领域还有各种各样的模型，它们各有特点。但不管形式怎么变化，本质都是一个函数。一个（或者更准确的是一种）模型一般都是一种函数形式，它有一些“参数”可以改变。而学习的过程就是不断调整这些参数，使得输出（尽量）接近“正确”的答案。&amp;nbsp;但是一般情况下很难所有的数据我们都能预测正确，所以一般我们会定义一个loss&amp;nbsp;function，可以理解为“错误”的程度，错的越“离谱”，loss就越大。而我们的目标就是调整参数使得loss最小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是我们是在“训练”数据上调整的参数，那么它能在“测试”数据上也表现的好吗？这个就是模型的“泛化”能力了。就和人在学校学习一样，有的同学做过的一&amp;nbsp;模一样的题就会，但是考试时稍微改变一下就不会了，这就是“泛化”能力太差，学到的不是最本质的东西。所以平时会定期有一些“模拟考试”，来检验学生是不&amp;nbsp;是真的学会了，如果考得不好，那就打回去重新训练模型调整参数。这在机器学习里对应的就是validation的阶段。最后到最终的考试了，就是最终检验&amp;nbsp;的时候了，这个试卷里的题目是不能提前让人看到的，只能拿出来用一次，否则就是作弊了。对应到机器学习里就是test阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然这里用通俗的话描述了机器学习，主要是有监督的学习。其实机器学习还有无监督的学习和强化学习。前者就是不给答案，只给数据，让人总结规律；而后者会有答案，但是答案不是现在就告诉你。我个人觉得人类社会里更多的是监督学习和强化学习。从人类社会总体来说，强化学习是获取新知识的唯一途径，也就是向自&amp;nbsp;然学习，我们做了一个决策，其好坏可能要很长一段时间才能显现出来。而学习出来的这些知识通过监督的方式，通过家庭和学校的教育教给下一代。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外输出除了简单的分为离散和连续，还可以是序列（时序）的，比如自然语言（文本）是一个字符串的序列&amp;nbsp;，对于我们的Image&amp;nbsp;Caption&amp;nbsp;Generation就是生成一个单词序列。另外还有更复杂的输出，比如parsing，输出是一棵语法树。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;2.2&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;多层神经网络&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面介绍了机器学习的基本概念，接下来我们就来学习一下神经网络。现在流行的说法“深度学习”，其实大多指的就是“深度神经网络”，那么首先我们先了解一下“浅度神经网络”，也就是传统的神经网络。这里的内容主要来自&lt;span&gt;http://neuralnetworksanddeeplearning.com&lt;/span&gt;的前两章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2.1&amp;nbsp;手写数字识别问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在学习一门新的语言时会写一个hello&amp;nbsp;world程序，而mnist数据的手写数字识别就是一个很好的学习机器学习（包括深度学习）的一个hello&amp;nbsp;world任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;计算机和人类大脑似乎有很大的不同，很多人类认为复杂的工作计算机可能认为很简单，而人类认为很简单的事情计算机可能非常难处理。比如数字的计算，记忆，人类的准确度和速度都远远不如计算机。但是识别0-9的手写数字，我们觉得很轻而易举的事情，让计算机程序来处理却异常困难。经过数百万年进化的人类视觉系统在我们大脑没有意识到的时候就已经帮我们完成了数字的识别，把那些复杂的视觉处理过程深深的掩藏了起来。但当我们想自己写一个程序来识别数字的时候，这些困难才能体现出来。首先，对于计算机来说，它“看到”的不是数字，甚至不是笔画。它“看到”的只是一个二位的矩阵（数组），每个点都是一个数字。比如下图，我们“看到”的是左边的“猫”，其实计算机“看到”的是右边的像素灰度值。当然我们视觉系统的视网膜看到的也是类似的一些“数值”，只不过我们的视觉系统已经处理了这些信息并且把它识别成了“猫”（甚至和语言还做了映射）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcskfN7Sfq38pGrefoWx2NakJBX3GarG9ANl9Zv3LICAwHdRNjWmAnQzw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MNIST数据介绍：MNIST的每个图片经过缩放和居中等预处理之后，大小是28*28，每个点都是0-255的灰度值，下图是一些样例。总共有60,000个训练数据（0-9共10个类别，每个类别6,000个）和10,000个测试数据。一般会拿60000个中的50000个来做训练集，而剩下的10000个用来做验证集（用来选择一些超参数）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsL9wvuNCNevcCG1t6KtHp4AK8ERsUasxBnW5mDl6SfDQnibqHR4r0ibGw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;mnist样例数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;如果我们自己来写一个“算法”识别数字“9”，我们可能会这么定义：9在上面有个圆圈，在这个圆圈的右下部分有一个竖直的笔画。说起来很简单，如果用算法&amp;nbsp;来实现就很麻烦了：什么是圆圈？每个人画的圆圈都不同，同样竖直的笔画怎么识别，圆圈和竖直笔画连接处怎么寻找，右下是哪？大家如果有兴趣可以尝试一下用&amp;nbsp;上面的方法，其实最早做数字识别就是这样的思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;机器学习的思路则不同，它不需要这么细节的“指示”计算机应该怎么做。而是给计算机足够的“训练”样本，让它“看”不同的10个数字，然后让它“学”出&amp;nbsp;来。前面我们也讲了，现在的机器学习一般是一个参数化的模型。比如最简单的一个线性模型：f(w;x)=w0+&amp;nbsp;w1*x1+w2*x2。如果我们的输入有两个“特征”x1和x2，那么这个模型有3个参数w0,w1和w2，机器学习的过程就是选择“最优”的参数。对&amp;nbsp;于上面的mnist数据，输入就是28*28=784维的向量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果用“原始”的输入作为“特征”，线性的模型很可能学到一些简单的特征，比如它看到1一般是分布在从上到下居中的一些位置，那么对于这些位置一旦发现有比较大的灰度值，那么就倾向于判断成1。如果一个像素点2也经常出现，但3不出现，那么它就能学到如果这个像素出现，那么这个数字是2和3的可能性就大一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是这样的“特征”可能不是“本质”的，因为我写字的时候笔稍微平移一点，那么你之前“学到”的参数就可能有问题。而更“本质”的特征是什么呢？可能还是像之前我们总结的——9在上面有个圆圈，在这个圆圈的右下部分有一个竖直的笔画。我们把识别一个数字的问题转化成圆圈和竖直笔画的问题。传统的机器学习需要方法来提取“类似”（但不完全是）基本笔画这样的“特征”，这些特征相对于像素的特征会更加“本质”。但是要“提取”这些特征需要很多的“领域”知识，比如图像处理的技术。所以使用传统的机器学习方法来解决问题，我们不但需要很多机器学习的知识，而且也需要很多“领域”的知识，同时拥有这两方面的知识是比较难的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而“深度学习”最近之所以火热，其中很重要的一个原因就是对于很多问题，我们只需要输入最原始的信号，比如图片的像素值，通过“多层”的网络，让底层的网络学习出“底层”的特征，比如基本的形状，而中间的层学习出抽象一点的特征，比如眼睛鼻子耳朵。而更上的层次识别出这是一个猫还是一个狗。所有这些都是机器学习出来的，所以基本不需要领域的知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsNyc6fnKpX7xAZtYJtUibx66DbBKberBCKaYT5jrJG2MZIJicMCkEiaM1g/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面的图就说明了这一点，而且我们发现越是底层的特征就越“通用”，不管是猫鼻子还是狗眼睛，可能用到的都是一些基本的形状，因此我们可以把这些知识（特征）transfer到别的任务，也就是transfer&amp;nbsp;learning，后面我们讲到CNN的时候还会提及。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2.2&amp;nbsp;单个神经元和多层神经网络(MLP)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;神经网络从名字来看是和人类的大脑有些关系的，而且即使到现在，很多有用的东西如CNN和Attention，都有很多借鉴神经科学研究人脑的结果的。不过这里我就不介绍这些东西了，有兴趣的读者可以找一些资料来了解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个神经元如下图的结构：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsXSribFetfaHOqGPHlJLPLlliaJibMxcia99cpEz3RSzZic3GYfhKpevMOSw/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的输入是一个向量，(x1,x2,x3)，输出是一个标量，一个实数。z=w0+&amp;nbsp;w1*x1&amp;nbsp;+&amp;nbsp;w2*x2&amp;nbsp;+&amp;nbsp;w3*x3。z是输入的加权累加，权值是w1,w2,w3，w0是bias，输出&amp;nbsp;output&amp;nbsp;=&amp;nbsp;f(z)。函数f一般叫做激活函数。最早流行的激活函数是Sigmoid函数，当然现在更流行Relu和它的改进版本。Sigmoid函数的公式和图形如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsTLPEV0ewZOcPx4JMaDrd13XAhVNJn4AJefE72KwmZXYfKzAzOiaNtOw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsN47X6B7zfaSskJVabYArSaiaVkrcUZhhlRJjCszEbcwzkCDIibeV1dTg/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当z=0时，sigmoid(z)=0.5&amp;nbsp;z趋于无穷大时，sigmoid(z)趋近于1，z趋于负无穷，值趋于0。为什么选择这样的激活函数呢？因为是模拟人脑的神经元。人脑的神经元也是把输入的信号做加权累加，然后看累加和是否超过一个“阈值”。如果超过，继续向下一个神经元发送信号，否则就不发送。因此人脑的神经元更像是一个阶跃函数：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsnHWyvtsMiapBeicdTiakY8OqQJic2hbq3G2ia97icqmf4tnriafVjyOAWq4IA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最早的感知机(Perception)其实用的就是这个激活函数。但是它有一个缺点就是0之外的所有点的导数都是0，在0点的导数是无穷大，所以很难用梯度的方法优化。而Sigmoid函数是处处可导。下面我手工推导了一下，如果大家不熟悉可以试着推导一下Sigmoid函数的导数，我们后面也会用到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsNJ400iaCiaHGBPgKlYah09T8fZ1M7UbgZt0E9HqvLDcugicnNjkiaeZzCQ/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们把许多的单个神经元按照层次组织起来就是多层的神经网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsGU25H4l3YO6et5Gb6lVqUbUktcoC8mKnUlBbHCrZSqR2iaTmM7kUjyA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如我们的手写数字识别，输入层是784维，就是神经网络的地一层，然后中间有15个hidden（因为我们不知道它的值）神经元，然后输出层是10个神经元。中间隐层的每个神经元的输入都是784个原始像素通过上面的公式加权累加然后用sigmoid激活。而输出层的每一个神经元也是中间15个神经元的累加然后激活。上面的图就是一个3层的神经网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;输入一个28*28的图像，我们得到一个10维的输出，那么怎么分类呢？最直接的想法就是把认为最大的那个输出，比如输出是（10,11,12,13,14,15,16,17,18,19)，那么我们认为输出是9。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，更常见的做法是最后一次经过线性累加之后并不用Sigmoid函数激活，而是加一个softmax的函数，让10个输出加起来等于1,这样更像一个&amp;nbsp;概率。而我们上面的情况，虽然训练数据的输出加起来是1,但是实际给一个其它输入，输出加起来很可能不是1。不过为了与Nielsen的文章一致，我们还&amp;nbsp;是先用这种方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，假设我们有了这些参数【总共是784*15&amp;nbsp;+&amp;nbsp;15(w0或者叫bias)&amp;nbsp;+&amp;nbsp;15*10&amp;nbsp;+&amp;nbsp;10】，我们很容易通过上面的公式一个一个的计算出10维的输出。然后选择最大的那个作为我们识别的结果。问题的难点就在怎么&amp;nbsp;选择这么多参数，然后使得我们分类的错误最少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我们怎么训练呢？对于一张图片，假设它是数字“1”，那么我们期望它的输出是（0,1,0,0,0,0,0,0,0,0)，所以我们可以简单的用最小平方错误作为损失函数。不过你可能会有些疑问，我们关注的指标应该是分类的“正确率”（或者错误率），那么我们为什么不直接把分类的错误率作为损失函数呢？这样神经网络学习出来的参数就是最小化错误率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要的原因就是错误率不是参数的连续函数。因为一个训练数据如果分类正确那么就是1，否则就是0，这样就不是一个连续的函数。比如最简单的两类线性分类器，f(x)=w0+w1*x1+w2*x2。如果f(x)&amp;gt;0我们分类成类别1；否则我们分类成类别2。如果当前的w0+w1*x1+w2*x2&amp;lt;0，我们很小的调整w0(或者w1,w2)，w0+w1*x1+w2*x2仍然小于0，【事实上对于这个例子，只要是w0变小，他们的累加都是小于0的】所以f(x)的值不会变化，而w0一直增大到使累加和等于0之前都不会变化，只有大于0时突然变成1了，然后一直就是1。因此之前的错误率都是1，然后就突然是0。所以它不是个连续的函数。因为我们使用的优化算法一般是（随机）梯度下降的算法，在每次迭代的时候都是试图做一个微小的参数调整使得损失变小，但是不连续的函数显然也不可导，也就没法用这个算法来优化参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此我们使用了最小平方误差(MSE)损失函数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcs2s8jvzz0YlurYamEE9MDvQCxuJU51XicVpFtgtv7nicvXAk7F9eCY94A/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;y(x)就是神经网络的输出，可能写成f(x)大家会习惯一点。a是目标的输出，比如当前分类是数字1，那么我们期望的输出就是（0,1,0,0,0,0,0,0,0,0)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先这个损失函数是参数w的连续函数，因为y(x)就是神经网络的输出，每个神经元都是它的输入的线性加权累加，然后使用sigmoid激活函数【如果使用最早的阶跃函数就不连续了，所以后来使用了Sigmoid函数】，然后每一层的神经元都是用上一层的神经元通过这样的方式计算的（只不过每个神经元的参数也就是权重是不同的数值而已），所以这些连续函数的复合函数也是连续的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次这个损失函数和我们的最终优化目标是“大致”一致的。比如C(w,b)趋于0时，它就要求y(x)趋于a，那么我们的分类也就趋于正确。当然可能存在一种极端的情况，比如有3个训练数据，第一组参数，它分类正确了2个训练数据，但是错的那1个错的很“离谱”，也就是y(x)和a差距极大；而第二组参数，他正确分类了1个训练数据，但是错的那两个都还不算太差。那么这种情况下MSE和正确率并不一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2.3&amp;nbsp;随机梯度下降(Stochastic&amp;nbsp;Gradient&amp;nbsp;Descent)和自动求梯度(Automatic&amp;nbsp;Derivatives)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面说了，我们有了一个参数化的模型，训练的过程就是根据训练数据和loss&amp;nbsp;function，选择“最优”的参数，使得loss“最小”，这从数学上来讲就是一个优化问题。这看起来似乎不是什么值得一提的问题，也许你还记得微积&amp;nbsp;分里的知识，极值点的各种充分必要条件，比如必要条件是导数是0，然后直接把参数解出来。但在现实生活中的函数远比教科书里学到的复杂，很多模型都无法用&amp;nbsp;解析的方式求出最优解。所以现实的方法就是求“数值”解，一般最常见的方法就是迭代的方法，根据现在的参数，我们很小幅度的调整参数，使得loss变小一&amp;nbsp;点点。然后一步一步的最终能够达到一个最优解（一般是局部最优解）。那怎么小幅调整呢？像闷头苍蝇那样随机乱试显然效率极低。因此我们要朝着一个能使函数&amp;nbsp;值变小的方向前进。而在一个点能使函数值变小的方向有无穷多个，但有一个方向是下降速度最快的，那就是梯度。因此更常见的方法就是在当前点求函数的梯度，&amp;nbsp;然后朝着梯度的方向下降。朝梯度的方向走多远呢？一般走一个比较小的值是比较安全的，这个值就是“步长”。一般刚开始随机的初始化参数，loss比较大，&amp;nbsp;所以多走一些也没关系，但是到了后面，就不能走太快，否则很容易错过最优的点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为loss是所有训练数据的函数，所以求loss的梯度需要计算所有的训练数据，对于很多task来说，训练数据可能上百万，计算一次代价太大，所以一&amp;nbsp;般会“随机”的采样少部分数据，比如128个数据，求它的梯度。虽然128个点的梯度和一百万个的是不一样的，但是从概率来讲至少是一致的方向而不会是相&amp;nbsp;反的方向，所以也能使loss变小。当然这个128是可以调整的，它一般被叫做batch&amp;nbsp;size，最极端的就是batch是1和一百万，那么分别就是online&amp;nbsp;learning和退化到梯度下降。batch&amp;nbsp;size越大，计算一次梯度的时间就越久【当然由于GPU和各种类似SSE的指令，一次计算128个可能并不比计算1个慢多少】，随机梯度和真正梯度一致&amp;nbsp;的概率就越大，走的方向就更“正确”；batch&amp;nbsp;size越小，计算一次的时间就越短，但可能方向偏离最优的方向就更远，会在不是“冤枉路”。但实际的情况也很难说哪个值是最优的，一般的经验取值都是几&amp;nbsp;十到一两百的范围，另外因为计算机都是字节对齐，32,64,128这样的值也许能稍微加快矩阵运算的速度。但是实际也很多人选择10,50,100这样&amp;nbsp;的值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了常见的随机梯度下降，还有不少改进的方法，如Momentum，Adagrad等等，有兴趣的可以看看http://cs231n.github.io/neural-networks-3/#update&amp;nbsp;，里面还有个动画，比较了不同方法的收敛速度的比较。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面的分析，我们把问题变成了怎么求loss对参数W的梯度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;求梯度有如下4种方法：&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.手工求解析解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如&amp;nbsp;f(x)=x^2，&amp;nbsp;df&lt;/span&gt;&lt;span&gt;=2*x。然后我们要求f(x)在x=1.5的值，代进去就2*1.5=3&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.数值解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用极限的定义：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcs8Ac8lsCcianTXooCkmOtInOP3P4fBf1mZHzeFoLCY80HZr5vkvJuzqA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.机器符号计算&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;让机器做符号运算，实现1的方法，但是机器如果优化的不好的话可能会有一些不必要的运算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如&amp;nbsp;x^2&amp;nbsp;+&amp;nbsp;2*x*y&amp;nbsp;+&amp;nbsp;y^2，直接对x求导数变成了&amp;nbsp;2*x&amp;nbsp;+&amp;nbsp;2*y，两次乘法一次加分，但是我们可以合并一下变成2*（x+y)，一次乘法一次加分。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.自动梯度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我会在稍微细讲一下，所以这里暂时跳过。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些方法的优缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.手工求解“数学”要求高，有可能水平不够求不对，但效率应该是能最优的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.没任何函数，甚至没有解析导数的情况下都能使用，缺点是计算量太大，而且只是近似解【因为极限的定义】，在某些特别不“连续”的地方可能误差较大。所以实际使用是很少，只是用它来验证其它方法是否正确。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.机器符号计算，前面说的，依赖于这个库的好坏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;实际的框架，如TensorFlow就是自动梯度，而Theano就是符号梯度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2.4&amp;nbsp;编程实战&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面的介绍，我们其实就可以实现一个经典的前馈(feed&amp;nbsp;forward)神经网络了，这种网络结构很简单，每一层的输入是前一层的输出。输入层没有输入，它就是原始的信号输入。而且上一层的所有神经元都会连接到下一层的所有神经元，就像我们刚才的例子，输入是784，中间层是15，那么就有785*15个连接【再加上每个中间节点有一个bias】。所以这种网络有时候也加做全连接的网络（full&amp;nbsp;connected)，用来和CNN这种不是全连接的网络有所区别，另外就是信号是从前往后传递，没有反馈，所以也叫前溃神经网络，这是为了和RNN这种有反馈的区别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，我们还没有讲怎么计算梯度，也就是损失函数相对于每一个参数的偏导数。在下一部分我们会详细讨论介绍，这里我们先把它当成一个黑盒的函数就好了。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.代码&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;我们这里学习一下Nielsen提供的代码。代码非常简洁，只有不到100行代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;https://github.com/mnielsen/neural-networks-and-deep-learning&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;git&amp;nbsp;clone&amp;nbsp;https://github.com/mnielsen/neural-networks-and-deep-learning.git&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2.运行&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;创建一个&amp;nbsp;test_network1.py，输入如下代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;import mnist_loader&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;import network&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;training_data, validation_data, test_data = mnist_loader.load_data_wrapper()&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;net = network.Network([784, 30, 10])&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;net.SGD(training_data, 30, 10, 3.0, test_data=test_data)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;保存后直接运行&amp;nbsp;Python&amp;nbsp;test_network1.py。这里我们让他进行了30次迭代，最终在测试数据上的准确率大概在95%左右（当然因为随机初始化参数不同，最终的结果可能有所不同）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;Epoch 0: 8250 / 10000&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Epoch 1: 8371 / 10000&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Epoch 2: 9300 / 10000&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;......&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Epoch 28: 9552 / 10000&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Epoch 29: 9555 / 10000&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;3.代码阅读&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Python代码很容易阅读，即使之前没有用过，稍微学习两天也就可以上手，而且大部分机器学习相关的代码不会用到太复杂的语言特性，基本就是一些数学的线性代数的运算。而Python的numpy这个库是用的最多的，后面阅读代码的时候我会把用到的函数做一些介绍，继续下面的阅读之前建议花十分钟阅读一下&lt;span&gt;&amp;nbsp;http://cs231n.github.io/python-numpy-tutorial/&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3.1&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;mnist_loader.load_data_wrapper函数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个函数用来读取mnist数据，数据是放在data/mnist.pkl.gz。首先这是个gzip的压缩文件，是Pickle工具序列化到磁盘的格式。不熟悉也没有关系，反正我们知道这个函数的返回值就行了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个函数返回三个对象，分别代表training_data，validation_data和test_data。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;training_data是一个50,000的list，然后其中的每一个元素是一个tuple。tuple的第一个元素是一个784维的numpy一维数组。第二个元素是10维的数组，也就是one-hot的表示方法——如果正确的答案是数字0，那么这个10维数组就是(1,&amp;nbsp;0,&amp;nbsp;0,&amp;nbsp;…)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而validation_data是一个10,000的list，每个元素也是一个tuple。tuple的第一个元素也是784维的numpy一维数组。第二个元素是一个0-9的数字，代表正确答案是那个数字。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;test_data的格式和validation_data一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么training_data要是这样的格式呢？因为这样的格式计算loss更方便一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3.2&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;Network类的构造函数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在调用net&amp;nbsp;=&amp;nbsp;network.Network([784,&amp;nbsp;30,&amp;nbsp;10])时就到了init函数。为了减少篇幅，代码里的注释我都去掉了，重要的地方我会根据自己的理解说明，但是有空还是值得阅读代码里的注释。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;class Network(object):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; def __init__(self, sizes):self.num_layers = len(sizes)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.sizes = sizes&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.biases = [np.random.randn(y, 1) for y in sizes[1:]]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.weights = [np.random.randn(y, x)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for x, y in zip(sizes[:-1], sizes[1:])]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如上面的参数，我们保存下来的self.num_layers=3，也就是3层的网络。每一层的神经元的个数保存到self.sizes里。接下来就是构造biases数组并随机初始化。因为输入层是没有参数的，所以是for&amp;nbsp;y&amp;nbsp;in&amp;nbsp;sizes[1:]，我们使用了numpy的random.randn生成正态分布的随机数用来作为参数的初始值。注意这里生成了2维的随机变量。回忆一下，如果我们有30个hidden&amp;nbsp;unit，那么bias的个数也是30，那就生成一个30维的1维数组就行了，为什么要是30*1的二维数组呢？其实用1维也可以，不过为了和weights一致，后面代码方便，就用二维数组了。另外weights也是一样的初始化方法，不过注意randn(y,x)而不是randn(x,y)。比如对于我们输入的[784,30,10]，weights分别是30*784和10*30的。当然其实weights矩阵转置一下也可以，就是计算矩阵乘法的时候也需要有一个转置。不同的文献可能有不同的记法，但是我们在实现代码的时候只需要随时注意矩阵的大小，检查矩阵乘法满足乘法的约束就行了，矩阵AB能相乘，必须满足的条件是Ｂ的列数等于Ａ的函数就行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于Nielsen的记法，矩阵的每一行就是一个神经元的784个参数，那么weights(30*784)&amp;nbsp;*&amp;nbsp;input(784*1)就得到30个hidden&amp;nbsp;unit的加权累加。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3.3&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;feedforward函数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给点输入a（784维），计算最终神经网络的输出（10维）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;def feedforward(self, a):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; """Return the output of the network if ``a`` is input."""for b, w in zip(self.biases, self.weights):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; a = sigmoid(np.dot(w, a)+b)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; return a&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码非常简单，这里用到了np.dot，也就是矩阵向量的乘法，此外这里有一个Sigmoid函数，这个函数的输入是numpy的ndarray，输出也是同样大小的数组，不过对于每个元素都进行了sigmoid的计算。用numpy的术语就是universal&amp;nbsp;function，很多文献里一般都叫elementwise的function。我觉得后面这个名字更直接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;#### Miscellaneous functionsdef sigmoid(z):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; """The sigmoid function."""return 1.0/(1.0+np.exp(-z))&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;def sigmoid_prime(z):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; """Derivative of the sigmoid function."""return sigmoid(z)*(1-sigmoid(z))&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面就是Sigmoid函数，另外也把sigmoid_prime，也就是Sigmoid的导数放在了一起【不记得的话看前面Sigmoid的导数的推导】。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3.4&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;SGD函数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个函数是训练的入口，比如我们之前的训练代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;net.SGD(training_data, 30, 10, 3.0, test_data=test_data)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;def SGD(self, training_data, epochs, mini_batch_size, eta,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; test_data=None):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;if test_data: n_test = len(test_data)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; n = len(training_data)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; for j in xrange(epochs):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; random.shuffle(training_data)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; mini_batches = [&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; training_data[k:k+mini_batch_size]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for k in xrange(0, n, mini_batch_size)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for mini_batch in mini_batches:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.update_mini_batch(mini_batch, eta)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if test_data:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; print "Epoch {0}: {1} / {2}".format(&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; j, self.evaluate(test_data), n_test)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; else:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; print "Epoch {0} complete".format(j)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一个参数就是training_data。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个参数就是epochs，也就是总共对训练数据迭代多少次，我们这里是30次迭代。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三个参数是batch大小，我们这里是10，最后一个参数是eta，也就是步长，这里是3.0。除了网络结构（比如总共多少个hidden&amp;nbsp;layer，每个hidder&amp;nbsp;layer多少个hidden&amp;nbsp;unit），另外一个非常重要的参数就是步长。前面我们也讨论过了，步长太小，收敛速度过慢，步长太大，可能不收敛。实际的情况是没有一个万能的准则，更多的是根据数据，不停的尝试合适的步长。如果发现收敛太慢，就适当调大，反之则调小。所以要训练好一个神经网络，还是有很多tricky的技巧，包括参数怎么初始化，激活函数怎么选择，比SGD更好的优化算法等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四个参数test_data是可选的，如果有（我们的例子是穿了进来的），则每次epoch之后都测试一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码的大致解释我用注释的形式嵌在代码里了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp;&lt;span&gt; &amp;nbsp; for j in xrange(epochs): ## 一共进行 epochs=30 轮迭代&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; random.shuffle(training_data) &amp;nbsp;## 训练数据随机打散&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; mini_batches = [&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; training_data[k:k+mini_batch_size]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for k in xrange(0, n, mini_batch_size)] ## 把50,000个训练数据分成5,000个batch&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个batch包含10个训练数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for mini_batch in mini_batches: ## 对于每个batch&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.update_mini_batch(mini_batch, eta) ## 使用梯度下降更新参数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if test_data: ## 如果提供了测试数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; print "Epoch {0}: {1} / {2}".format(&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; j, self.evaluate(test_data), n_test) ## 评价在测试数据上的准确率&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; else:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; print "Epoch {0} complete".format(j)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面是evaluate函数：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;def evaluate(self, test_data):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; test_results = [(np.argmax(self.feedforward(x)), y)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (x, y) in test_data]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; return sum(int(x == y) for (x, y) in test_results)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于test_data里的每一组(x,y)，y是0-9之间的正确答案。而self.feedforward(x)返回的是10维的数组，我们选择得分最高的那个值作为模型的预测结果np.argmax就是返回最大值的下标。比如x=[0.3,&amp;nbsp;0.6,&amp;nbsp;0.1,&amp;nbsp;0,&amp;nbsp;….]，那么argmax(x)&amp;nbsp;=&amp;nbsp;1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此test_results这个列表的每一个元素是一个tuple，tuple的第一个是模型预测的数字，而第二个是正确答案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以最后一行返回的是模型预测正确的个数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3.5&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;update_mini_batch函数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;def update_mini_batch(self, mini_batch, eta):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;nabla_b = [np.zeros(b.shape) for b in self.biases]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; nabla_w = [np.zeros(w.shape) for w in self.weights]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; for x, y in mini_batch:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; delta_nabla_b, delta_nabla_w = self.backprop(x, y)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nabla_b = [nb+dnb for nb, dnb in zip(nabla_b, delta_nabla_b)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nabla_w = [nw+dnw for nw, dnw in zip(nabla_w, delta_nabla_w)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; self.weights = [w-(eta/len(mini_batch))*nw&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for w, nw in zip(self.weights, nabla_w)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; self.biases = [b-(eta/len(mini_batch))*nb&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;for b, nb in zip(self.biases, nabla_b)]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的输入参数是mini_batch【size=10的tuple(x,y)】和eta【3.0】。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;def update_mini_batch(self, mini_batch, eta):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;nabla_b = [np.zeros(b.shape) for b in self.biases]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; ## 回忆一下__init__，biases是一个列表，包含两个矩阵，分别是30*1和10*1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; ## 我们先构造一个和self.biases一样大小的列表，用来存放累加的梯度（偏导数）&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; nabla_w = [np.zeros(w.shape) for w in self.weights]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; ## 同上， weights包含两个矩阵，大小分别是30*784和10*30&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; for x, y in mini_batch:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; delta_nabla_b, delta_nabla_w = self.backprop(x, y)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;## 对于一个训练数据(x,y)计算loss相对于所有参数的偏导数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ## 因此delta_nabla_b和self.biases， nabla_b是一样大小(shape)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ## 同样delta_nabla_w和self.weights,nabla_w一样大小&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nabla_b = [nb+dnb for nb, dnb in zip(nabla_b, delta_nabla_b)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ## 把bias的梯度累加到nabla_b里&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nabla_w = [nw+dnw for nw, dnw in zip(nabla_w, delta_nabla_w)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ## 把weight的梯度累加到nable_w里&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; self.weights = [w-(eta/len(mini_batch))*nw&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for w, nw in zip(self.weights, nabla_w)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;## 使用这个batch的梯度和eta（步长）更新参数weights&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; self.biases = [b-(eta/len(mini_batch))*nb&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;for b, nb in zip(self.biases, nabla_b)]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ## 更新biases&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ## 这里更新参数是除了batch的大小（10），有的人实现时不除，其实没有什么区别，因为超参数eta会有所不同，如果不除，那么eta相当于是0.3(在eta那里就除了batch的大小了）。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3.6&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;backprop函数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个函数就是求loss相对于所有参数的偏导数，这里先不仔细讲解，等下次我们学习梯度的求解方法我们再回来讨论，这里可以先了解一下这个函数的输入和输出，把它当成一个黑盒就行，其实它的代码也很少，但是如果不知道梯度的公式，也很难明白。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;def backprop(self, x, y):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;nabla_b = [np.zeros(b.shape) for b in self.biases]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; nabla_w = [np.zeros(w.shape) for w in self.weights]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; # feedforwardactivation = x&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; activations = [x] # list to store all the activations, layer by layerzs = [] # list to store all the z vectors, layer by layerfor b, w in zip(self.biases, self.weights):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; z = np.dot(w, activation)+b&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; zs.append(z)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; activation = sigmoid(z)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; activations.append(activation)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; # backward passdelta = self.cost_derivative(activations[-1], y) * \&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sigmoid_prime(zs[-1])&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; nabla_b[-1] = delta&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; nabla_w[-1] = np.dot(delta, activations[-2].transpose())&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;for l in xrange(2, self.num_layers):&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; z = zs[-l]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sp = sigmoid_prime(z)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; delta = np.dot(self.weights[-l+1].transpose(), delta) * sp&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nabla_b[-l] = delta&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; nabla_w[-l] = np.dot(delta, activations[-l-1].transpose())&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; return (nabla_b, nabla_w)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的输入就是一个训练样本(x,y)分别是784*1和10*1。输出就是和self.biases,self.weights一样大小的列表，然后列表中的每一个数组的大小也是一样。具体到上面的例子，输出nabla_b包含两个矩阵，大小分别是30*1和10*1；nabla_w也包含两个矩阵，大小分别是30*784和10*30。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;未完待续&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;作者简介：&lt;/strong&gt;李理，目前就职于环信，即时通讯云平台和全媒体智能客服平台，在环信从事智能客服和智能机器人相关工作，致力于用深度学习来提高智能机器人的性能。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;责编：&lt;/strong&gt;周建丁（zhoujd@csdn.net）&lt;/p&gt;&lt;p&gt;更多详细内容，请持续关注MDCC大会官网， 9 月 4 日零点前，MDCC 大会门票处于 6.8 折优惠票价阶段，五人以上团购更有特惠，限量供应（阅读原文获取票务详情，欲购从速！）&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;</description>
      <pubDate>Thu, 08 Sep 2016 19:59:01 +0800</pubDate>
    </item>
    <item>
      <title>浏览器存储及使用</title>
      <link>http://www.iwgc.cn/link/2613607</link>
      <description>&lt;p&gt;&lt;span&gt;伴随着WEB的发展，浏览器的存储方式及技术不断的发生更改，从刚开始的Cookie，到localStorage，sessionStorage，再到IndexedDB，再到现在的Web SQL，作为一名合格的前端开发，当然需要对这些技术了如指掌并熟练掌握，本文将比较全面的介绍常见的浏览器存储以及其使用。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsqrj7ia5m00FiaXJshkecaPqeGGJzytz0dO8CXl6utlia0B5FEecRQwSsQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;1&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;Cookie&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cookie是一个用户通过浏览器浏览网站产出的信息的票根，Cookies通常被用来标示一个网站用户的浏览经历，它可能包含这个用户的个人偏好或访问这个网站的一些输入信息。用户可以自己随意操作他们浏览器中的Cookie。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cookies可以通过服务端使用Set-Cookie Http header来设置和修改，当然也可以使用javascript的document.cookie去操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;浏览器兼容性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcs9wDhGRV7jocgiaQ8iaOSLo0Bglu6ceeHiblEbny5PlRlfBocicR8lKk5aA/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细请参考：&lt;span&gt;http://caniuse.com/#search=cookie&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;在浏览器中操作如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;//读取网站下所有的cookie信息，获取的结果是一个以分号;作为分割的一个字符串&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var allCookies = document.cookie;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//例如：在百度首页，获取的如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// "BAIDUID=B32F2BF6BCB66D5559E199F5B1908F4C:FG=1; PSTM=1444711125; BIDUPSID=9DE77BD4B191F421CA54DB11C954067A; ispeed_lsm=0; MCITY=-289%3A; BDSFRCVID=hWtsJeC62Ag8XZc4Nvqo2MixJD2vkWoTH6aoB7vKuwGS_LREoJS6EG0PtvlQpYD-KiV2ogKK0eOTHvvP; H_BDCLCKID_SF=JbADoDD-JCvbfP0kKtr_MJQH-UnLq-vUbT7Z0l8KtqjJbMnL-TOF5R_eD4c0hUTRtjcW-b7mWIQHDp_65xRh5U-9BPvN04RZLbc4KKJxbPQSVtJXQKcvMq5XhUJiB5O-Ban7LtQxfJOKHICRe5-ajxK; BD_CK_SAM=1; locale=zh; BD_HOME=0; H_PS_PSSID=1455_18241_18559_17000_15227_11651; BD_UPN=123253"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//往原来的已经存在的cookie中加入新的cookie&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;document.cookie ="test=yui";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//当然也可以在后面加上可选择的选项键值对，例如domain，以及其他path，expires&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;document.cookie="test=yui;domain=.baidu.com"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//删除cookie，就是让这个cookie值得expires过，就是设置这个expires为0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;document.cookie="test=yui;domain=.baidu.com;expires=0");&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;需要注意的地方：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1) 通过上面的代码，可以看到document.cookie是个可访问的属性，但是它有内置的setter和getter的function，而不是一个简单的字符串数据，你的get和set都会调用这些原生内置的函数；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2) Cookie支持跨域，可以通过在根域名设置cookie，共享多个子域名的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;Cookie的Chrome浏览器实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cookie解析：&lt;span&gt;https://code.google.com/p/chromium/codesearch#chromium/src/net/cookies/parsed_cookie.h&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;2&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;Web Storage&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Web Storage有两种机制，分别为sessionStorage和localStorage。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage是一种半持久化的本地存储（会话级别的存储），而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两个对象，对外的方法主要有：setItem、getItem，以键值对的形式存储和读取，key按照索引获取当前存储的key值，找不到时返回null，length属性代表当前存储的key value对数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;浏览器兼容性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsfhAicBQ7ZRYMZg5E5cJbVC5AH5tEPib4W0GgeLeO3oWLn7c3k0liaia7kQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细请参考：&lt;span&gt;http://caniuse.com/#search=localstorage&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;代码示例（&lt;span&gt;以localStorage为例&lt;/span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;var username = 'helloworld';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var storageUsername;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var randomArr = [Math.random()，Math.random()，Math.random()，Math.random()];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var storageRandomArr;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//storage username，key值区分大小写，存入的内容为这个变量调用toString方法的结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage.setItem("username"，username);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//获取&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;storageUserName &amp;nbsp;= localstorage.getItem("username");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//"helloworld"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//删除&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage.removeItem("username");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;storageUserName &amp;nbsp;= &amp;nbsp;localstorage.getItem("username");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// null&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//存储对象时，可以先调用JSON.stringify方法，然后取出的时候再调用JSON.parse方法获取结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage.setItem("randomarr"，JSON.stringify(randomArrr));&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;storageRandomArr = JSON.parse(localStorage.getItem("randomarr"));&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Object.prototype.toString.call(storageRandomArr);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// "object Array"&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;IndexDB&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IndexedDB是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的API。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IndexedDB分别为同步和异步访问提供了单独的API，异步API方法调用完后会立即返回，而不会阻塞调用线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要异步访问数据库，要调用Window对象IndexedDB属性的open()方法。该方法返回一个IDBRequest对象(IDBOpenDBRequest)；异步操作通过在IDBRequest对象上触发事件来和调用程序进行通信。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IndexDb是NoSQL数据库，是一种支持事务的浏览器数据库，基本操作就是，打开数据库，增删改查各种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;浏览器兼容性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsvUJfEKLzFAOmm3rGuAw1wibJQteEx4JSOm38d38JLnwxClkN39iaDVrg/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细请参考：&lt;span&gt;http://caniuse.com/#search=IndexDB&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;代码示例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1) 打开数据库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;//处理浏览器兼容性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//如果该数据库MyDatabase不存在，则会被创建；如果已经存在，则被打开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open("MyDatabase");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//打开数据库失败的回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; console.log("failure");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//代开数据成功的回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onsuccess = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; console.log("success");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2) 初始化数据库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;var dbName = "MyDatabase";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var dbVersion = 2;//整数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// open函数接受的第二个参数，代表数据的版本，当打开的版本号比当前的版本号大时，会触发onupgradeneeded这个回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open(dbName，dbVersion);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var studentsData = [{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"001"，name:"xiaoming"，email:0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}，{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"002"，name:"xiaoxiang"，email:1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var tableName = 'students';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //错误处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onupgradeneeded = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var db = event.target.result;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //创建表，以id字段作为主键来确保唯一，使用keyPath表示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var objectStore = db.createObjectStore(tableName， { keyPath: "id" });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //给表添加索引&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore.createIndex("name"，"name"，{unique:false});//非unique索引&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore.createIndex("email"，"email"，{unique:true});//email字段作为unique索引&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; for(var i in studentsData){&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //插入数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; objectStore.add(studentsData[i]);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; console.log("---init db success---");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3) 使用事务添加、删除数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;transaction()方法接受两个参数并返回一个事务对象。第一个参数是事务希望跨越的对象存储空间的列表，即数据库中的表名称。如果你希望事务能够跨越所有的对象存储空间你可以传入一个空数组。第二个参数如果你没有为第二个参数指定任何内容，默认只读。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsB6xPTUvRTb1oqaiaOIvTUUE7tKJtXvojRHsw51seYjMDtC2glBonZOA/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;插入学生003，004，005&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;var dbName = "MyDatabase";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open(dbName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var addData = [{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"003"，name:"xiaofang1"，email:"3@qq.com"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}，{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"004"，name:"xiaofang2"，email:"4@qq.com"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}，{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"005"，name:"xiaofang3"，email:"5@qq.com"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var tableName = 'students';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//打开数据库失败的回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; console.log("open indexDb database failure");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//代开数据成功的回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onsuccess = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var db = event.target.result;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var transaction = db.transaction([tableName]，'readwrite');&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var objectStore;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var i;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //事务主要有三个回调，error，abort，success&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.onerror = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //处理错误&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(event);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.onbort = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //事务中断处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.oncomplete = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("添加数据成功");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore &amp;nbsp;= transaction.objectStore(tableName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; for(i &amp;nbsp;in addData){&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var request = objectStore.add(addData[i]);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; request.onsuccess = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("add one success");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;删除001学生&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;var dbName = "MyDatabase";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open(dbName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var db;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var tableName = 'students';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onsuccess &amp;nbsp;= function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var objectStore;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var transaction;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; db = &amp;nbsp;event.target.result;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction= db.transaction([tableName]，'readwrite');&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.onerror = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //处理错误&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("error when delete 001 "+ event.target.errorCode);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.onbort = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //事务中断处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.oncomplete = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("删除学生001成功");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore = transaction.objectStore(tableName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore.delete("001");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4) 使用索引查找数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要调用IDBObjectStore示例对象的index方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;var dbName = "MyDatabase";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open(dbName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var db;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var tableName = 'students';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onsuccess &amp;nbsp;= function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var index;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var objectStore;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; db = &amp;nbsp;event.target.result;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore = db.transaction([tableName]).objectStore(tableName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //根据索引字段email朝找3@qq.com的学生&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; index = objectStore.index("email").get("3@qq.com");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; index.onsuccess = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(event.target.result);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; };&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; index.onerror = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("error when find &amp;nbsp;by index "+ event.target.errorCode);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;indexDb还有游标查找功能，限于篇幅，就不展开介绍了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;4&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;WebSql&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Web SQL Database API实际上未包含在HTML 5规范之中，它是一个独立的规范，它引入了一套使用SQL操作客户端数据库的API，这些API有同步的，也有异步的，一般情况下，都会使用异步API。它的核心方法有三个：openDatabase，transaction和executeSql。这些API已经被广泛的实现在了不同的浏览器里，尤其是手机端浏览器。虽然W3C官方在2011年11月声明已经不再维护Web SQL Database规范，但由于其广泛的实现程度，了解这些API对Web开发还是非常有必要的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;浏览器兼容性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcscz5ymq3AY17tibvg7pM2oWhzpn8c0vsuOdUic5w3gY6HuuycGag2FibdQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详情请参考：&lt;span&gt;http://caniuse.com/#search=WebSql&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;代码示例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;var db;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var info = {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; dbName :"MyDataBase"，//数据库名称&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; dbVersion:"0.1"，//版本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; dbDisplayName:"测试数据库"，//显示名称&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; dbEstimatedSize:10*1024*1024 //数据库大小，单位字节&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db = window.openDatabase(info.dbName，info.dbVersion，info.dbDisplayName，info.dbEstimatedSize);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//初始化students表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db.transaction(function (trans) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //执行Sql，如果students表不存在，则创建改表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; trans.executeSql("create table if not exists students(id unique，name text null，email text null)"，[]， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("init success");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("error happen");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//插入数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db.transaction(function (trans) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; trans.executeSql("insert into students(name，email) values(?，?)"，['xiaoming'，'1@qq.com']， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("insert ok 1");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(arguments);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; trans.executeSql("insert into students(name，email) values(?，?)"，['xiaohong'，'2@qq.com']，function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("insert ok 2");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(arguments);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//删除数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db.transaction(function (trans) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;trans.executeSql("delete from students where name = ? "，['xiaohong']， function (trans，result) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.log("delete success");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;}， function (trans，message) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.log("error happen");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;});&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//查询数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db.transaction(function (trans) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; trans.executeSql("select * from students"，[]， function (trans，result) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("总共查询到 "+result.rows.length+" 条数据");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }， function (trans，message) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("error happen");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;5&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;其他&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;Application Cache&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Application Cache翻译成中文为应用程序缓存，是html5中为实现离线浏览所提供的API。结合Manifest文件使用，使用编程方式，更新浏览器缓存内容。主要调用update与swapCache去更新浏览缓存，目前该技术已经被最新的规范所废弃，转而使用了Service Workers。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;Service Workers&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个service worker是一段运行在浏览器后台进程里的脚本，它独立于当前页面，提供了一些不需要与web页面交互的功能，即那种在网页背后悄悄执行的能力。在将来，基于它可以实现消息推送，静默更新等服务，但是目前它首先要具备的功能是拦截和处理网络请求，包括可编程的响应缓存管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;6&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;小结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前Cookie的兼容性最好，使用的最广泛，但有被滥用的趋势。Web Storage兼容比较好，除了老板的IE 6，7不支持外，其他主流浏览器都已经支持了，使用起来也方便简单，适合存储键值对数据。WebSql由于未在HTML5规范中，前景堪忧，适当了解下。IndexDb目前来看，兼容性不太好，但是前景很好，目前由w3c在推广，相信在以后应该有个大爆发(个人看法)。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Application Cache目前已经被废弃，Service Workers目前属于起步阶段，感觉离实用还需要时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;参考链接&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;caniuse：http://caniuse.com/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Cookie：https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;谷歌开发者中心文档：https://developer.chrome.com/devtools/docs/resource-panel#inspecting-page-resources&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Mozilia 开发者中心：https://developer.mozilla.org/en-US/docs/Web&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ServiceWorkers：http://www.html5rocks.com/en/tutorials/service-worker/introduction/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;声明：&lt;/strong&gt;本文为CSDN原创投稿文章，未经许可，禁止任何形式的转载。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;作者：&lt;/strong&gt;叶文兵，MaxLeap UX组开发人员，负责公司主要项目前端开发工作，逐渐往Node.js全栈方向发展。本科毕业于安徽师范大学，入坑前端开发近3年。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;责编：&lt;/strong&gt;钱曙光，关注架构和算法领域，寻求报道或者投稿请发邮件qianshg@csdn.net，另有「CSDN 高级架构师群」，内有诸多知名互联网公司的大牛架构师，欢迎架构师加微信qshuguang2008申请入群，备注姓名+公司+职位。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016年9月22日-23日，SDCC 2016大数据技术&amp;amp;架构实战峰会将在杭州举行，两场峰会大牛讲师来自阿里、京东、苏宁、唯品会、美团点评、游族、饿了么、有赞、Echo等知名互联网公司，共同探讨海量数据下的应用监控系统建设、异常检测的算法和实现、大数据基础架构实践、敏捷型数据平台的构建及应用、音频分析的机器学习算法应用，以及高可用/高并发/高性能系统架构设计、电商架构、分布式架构等话题与技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9月4日24点前仍处于最低六折优惠票价阶段，单场峰会（含餐）门票只需499元，5人以上团购或者购买两场峰会通票更有特惠，限时折扣，预购从速。（票务详情http://bss.csdn.net/m/topic/sdcc_invite/hangzhou#goupiaoxinxi）。&lt;/span&gt;&lt;/p&gt;</description>
      <pubDate>Thu, 08 Sep 2016 19:59:01 +0800</pubDate>
    </item>
    <item>
      <title>聚类分析总结 &amp;amp; 实战解析</title>
      <link>http://www.iwgc.cn/link/2595352</link>
      <description>&lt;p&gt;聚类分析是没有给定划分类别的情况下，根据样本相似度进行样本分组的一种方法，是一种非监督的学习算法。聚类的输入是一组未被标记的样本，聚类根据数据自身的距离或相似度划分为若干组，划分的原则是组内距离最小化而组间距离最大化，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWuiaBLCSw4ibib2eUKU0vquX5hdYVXTecxZPPSpgX6eMupEJp7SquFYm76sQ9iawIgQdT33ox7JuFYjw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;常见的聚类分析算法如下：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;K-Means：&lt;/strong&gt; K-均值聚类也称为快速聚类法，在最小化误差函数的基础上将数据划分为预定的类数K。该算法原理简单并便于处理大量数据。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;K-中心点：&lt;/strong&gt;K-均值算法对孤立点的敏感性，K-中心点算法不采用簇中对象的平均值作为簇中心，而选用簇中离平均值最近的对象作为簇中心。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;系统聚类：&lt;/strong&gt;也称为层次聚类，分类的单位由高到低呈树形结构，且所处的位置越低，其所包含的对象就越少，但这些对象间的共同特征越多。该聚类方法只适合在小数据量的时候使用，数据量大的时候速度会非常慢。&lt;/p&gt;&lt;p&gt;下面我们详细介绍K-Means聚类算法。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;K-Means聚类算法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;K-Means算法是典型的基于距离的非层次聚类算法，在最小化误差函数的基础上将数据划分为预定的类数K，采用距离作为相似性的评价指标，即认为两个对象的距离越近，其相似度就越大。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;算法实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;选择K个点作为初始质心&lt;/p&gt;&lt;p&gt;&lt;strong&gt;repeat&lt;/strong&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2"&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;将每个点指派到最近的质心，形成K个簇&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;重新计算每个簇的质心&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;until 簇不发生变化或达到最大迭代次数&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;K如何确定&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;与层次聚类结合，经常会产生较好的聚类结果的一个有趣策略是，首先采用层次凝聚算法决定结果粗的数目，并找到一个初始聚类，然后用迭代重定位来改进该聚类。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;初始质心的选取&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;常见的方法是随机的选取初始质心，但是这样簇的质量常常很差。&lt;/p&gt;&lt;p&gt;(1)多次运行，每次使用一组不同的随机初始质心，然后选取具有最小SSE(误差的平方和)的簇集。这种策略简单，但是效果可能不好，这取决于数据集和寻找的簇的个数。&lt;/p&gt;&lt;p&gt;(2)取一个样本，并使用层次聚类技术对它聚类。从层次聚类中提取K个簇，并用这些簇的质心作为初始质心。该方法通常很有效，但仅对下列情况有效：样本相对较小;K相对于样本大小较小。&lt;/p&gt;&lt;p&gt;(3)取所有点的质心作为第一个点。然后，对于每个后继初始质心，选择离已经选取过的初始质心最远的点。使用这种方法，确保了选择的初始质心不仅是随机的，而且是散开的。但是，这种方法可能选中离群点。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;距离的度量&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;常用的距离度量方法包括：欧几里得距离和余弦相似度。欧几里得距离度量会受指标不同单位刻度的影响，所以一般需要先进行标准化，同时距离越大，个体间差异越大;空间向量余弦夹角的相似度度量不会受指标刻度的影响，余弦值落于区间[-1,1]，值越大，差异越小。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;质心的计算&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于距离度量不管是采用欧式距离还是采用余弦相似度，簇的质心都是其均值。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;算法停止条件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;一般是目标函数达到最优或者达到最大的迭代次数即可终止。对于不同的距离度量，目标函数往往不同。当采用欧式距离时，目标函数一般为最小化对象到其簇质心的距离的平方和;当采用余弦相似度时，目标函数一般为最大化对象到其簇质心的余弦相似度和。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;空聚类的处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果所有的点在指派步骤都未分配到某个簇，就会得到空簇。如果这种情况发生，则需要某种策略来选择一个替补质心，否则的话，平方误差将会偏大。&lt;/p&gt;&lt;p&gt;(1)选择一个距离当前任何质心最远的点。这将消除当前对总平方误差影响最大的点。&lt;/p&gt;&lt;p&gt;(2)从具有最大SSE的簇中选择一个替补的质心，这将分裂簇并降低聚类的总SSE。如果有多个空簇，则该过程重复多次。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;适用范围及缺陷&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;K-Menas算法试图找到使平方误差准则函数最小的簇。当潜在的簇形状是凸面的，簇与簇之间区别较明显，且簇大小相近时，其聚类结果较理想。对于处理大数据集合，该算法非常高效，且伸缩性较好。&lt;/p&gt;&lt;p&gt;但该算法除了要事先确定簇数K和对初始聚类中心敏感外，经常以局部最优结束，同时对“噪声”和孤立点敏感，并且该方法不适于发现非凸面形状的簇或大小差别很大的簇。&lt;/p&gt;&lt;p&gt;克服缺点的方法：使用尽量多的数据;使用中位数代替均值来克服outlier的问题。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;实例解析&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWuiaBLCSw4ibib2eUKU0vquX5NaRbdGwPRGXhA9UDkXCeII9jq8mHsPVXYjLZqDcec56ugQ9BwXlgPw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;下面我们用TSNE(高维数据可视化工具)对聚类结果进行可视化&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWuiaBLCSw4ibib2eUKU0vquX52Tt9ianxAoITPM2oSaKunibM0gNMeOyjgr70UzMQHPTC0D3fRqIm8sEQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;聚类效果图如下：&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWuiaBLCSw4ibib2eUKU0vquX5fj0KEZibRcH502JsuKokHW5HibWW5hHkbkz821zCicshV6HB7s0hbPfKA/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;下面我们用PCA降维后，对聚类结果进行可视化&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWuiaBLCSw4ibib2eUKU0vquX5akLVMf1dbXSVLpxJbryqasFjLicZ5wyZiayu3licq7uqCXGia0T0xlQZyw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;聚类效果图如下：&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWuiaBLCSw4ibib2eUKU0vquX5UcaYs8hbzl3uYiahtNUD06rEKic2hn7bpMsRkuycbLFdCK7RoZhZYsEw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;Python主要的聚类分析算法总结&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在scikit-learn中实现的聚类算法主要包括K-Means、层次聚类、FCM、神经网络聚类，其主要相关函数如下：&lt;/p&gt;&lt;ul class=" list-paddingleft-2"&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;KMeans: &lt;/strong&gt;K均值聚类;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;AffinityPropagation:&lt;/strong&gt; 吸引力传播聚类，2007年提出，几乎优于所有其他方法，不需要指定聚类数K，但运行效率较低;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;MeanShift&lt;/strong&gt;：均值漂移聚类算法;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;SpectralClustering&lt;/strong&gt;：谱聚类，具有效果比KMeans好，速度比KMeans快等特点;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;AgglomerativeClustering&lt;/strong&gt;：层次聚类，给出一棵聚类层次树;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;DBSCAN&lt;/strong&gt;：具有噪音的基于密度的聚类方法;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;BIRCH&lt;/strong&gt;：综合的层次聚类算法，可以处理大规模数据的聚类。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些方法的使用大同小异，基本都是先用对应的函数建立模型，然后用fit()方法来训练模型，训练好之后，就可以用labels_属性得到样本数据的标签，或者用predict()方法预测新样本的标签。&lt;/p&gt;</description>
      <pubDate>Wed, 07 Sep 2016 17:08:35 +0800</pubDate>
    </item>
    <item>
      <title>参加年度开发者大调查 Macbook Air等你来拿</title>
      <link>http://www.iwgc.cn/link/2595353</link>
      <description>&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;大家的月薪是多少？在近一年增长幅度是多少？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是否有跳槽计划？会选择什么类型的公司？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么开发语言使用最多？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在哪些Web开发工具使用的较多？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;......&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相信不少开发者都会有上述的疑惑或遇到类似的问题，为了勾勒出中国软件开发者当前最真实的生存状态和行业现状，2016年9月5日-10月10日CSDN发起“2016年中国软件开发者有奖大调查”活动，了解当下开发者的技能状态、开发工具配置、新技术应用等内容，希望能为软件开发者这一专属群体把脉。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本次大调查将于2019年9月5日到10月10日在CSDN官网进行&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;。&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;不论是否CSDN用户均可参与，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;CSDN还将从参与者中抽取幸运用户赠送丰厚大奖，回馈大家的辛苦付出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;奖项设置&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;特等奖两名 Macbook Air 11寸（1名），科大讯飞语音开发板（1名）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一等奖两名 Apple Watch Sport&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;二等奖四名 叮咚智能音箱&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;三等奖40名 IKBC键盘&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;四等奖100名 程序员2016年全年电子刊物&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;鼓励奖140名 程序员2016年10月刊一本&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;获奖规则&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所有奖项都将通过随机抽取的方式产生（使用CSDN ID登录参与调查，概率增加一倍哦），获奖名单将通过@CSDN 新浪官方微博以及CSDN微信公众号公布，请参与者随时关注我们的微博以及公众号，谢谢参与！（搜索微信号CSDNnews，即可关注CSDN微信）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAughm6icIMqoTcZVSeiclRaQLBoDjbKmSSJaeGvwwqgzAcXR9Hy2RKynbaMuwicaEGpTicwbF6yRSmiaBOw/0?wx_fmt=jpeg"/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;温馨提示&lt;/section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAughm6icIMqoTcZVSeiclRaQLB9VfLXIHQScmVbxGZuLuiaIibgPRsDcNDc9Wk5mibUK6ic3Yt6JiaArbpeEw/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;section&gt;填完本份调查问卷约需10~15分钟，无效问卷参与者不会纳入到抽奖环节中，谢谢合作。&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;【&lt;span&gt;点击原文，参与问答&lt;/span&gt;】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 07 Sep 2016 17:08:35 +0800</pubDate>
    </item>
    <item>
      <title>如何运用微服务来创建资产管理集成系统</title>
      <link>http://www.iwgc.cn/link/2595354</link>
      <description>&lt;p&gt;&lt;span&gt;在酒店行业，由于各类系统太过分散，进行整合势在必行。公司系统要与来自不同提供商的各类系统进行交互，这些系统的应用程序接口（API）也各不相同。此外，随着系统中录入的酒店客户增加，涉及的情况也越来越多，必须对其进行管理。由于这一行趋向互联化，资产管理系统（PMS）逐渐成为各大酒店的核心系统，而整合更是重中之重。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要想提供适用于酒店行业的软件解决方案，必须建立起与PMS供应商的双向集成系统。其中的挑战在于：我们需要大规模构建与管理这些联网的内容，并应对涉及多家酒店、多个PMS系统的情况。想要实现这些整合，有几种办法，本文将会介绍一个用于集成系统基础构建的简单架构设计方法。随着酒店发展，投资回报率（ROI）也会得以增加，而这种方法就使用到了微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;微服务是什么？&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;企业软件设计的思想领袖Martin Fowler曾为微服务下过一个全面的定义：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在过去几年中，“微服务架构”（Microservice Architecture）一词被广泛用于描述软件设计的某种特殊方式，即设计出一套独立的、可部署的服务。尽管这种架构风格尚无明确的定义，但在围绕着业务能力、自动化部署、终端智能、语言及数据的非集中控制方面，却有某些共同特征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本质来讲，微服务实际就是若干很小的软件组件，各个组件只专注于一件工作做好。不同于大型整体式的应用，使用微服务的应用各个部分可以拆开，每个部分只负责指定领域中每部分只需要在指定领域内专注管理一项功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正因如此，它们是各自独立且自治的。一项服务的变化也不会影响其他服务，不需要求其他部分一同进行变化。所以，当你慢慢壮大成熟时，不需要担心一旦有变化会影响到其他微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微服务的特点：小而专注、低耦合、高内聚&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;为何微服务如此强大?&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微服务架构能提供众多好处，主要有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;可扩展性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据不同的属性，单一的系统需要同多个PMS实体进行融合。假设需要与1000个属性进行融合，那么即使它们运行的是同一供应商提供的同一PMS系统，也需要对1000个不同的集成进行显示管理。为了添加更多的复杂性，这些实体可以是来自于不同的供应商。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当你加入更多的PMS实体和属性后，这一规模扩展得更大。如果你运行的是一个整体应用程序，那么你需要衡量所有事宜，因为它们是一个大整体。尤其是在访问量高峰期间，要想知道性能瓶颈在哪比较困难，而此时微服务会有更多的透明度。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果你利用的是微服务，那么在运行过程中是哪个服务出现了性能问题就一清二楚，而你也可以轻松地调整它们的容量（基础硬件），无需为正常运行的其他服务增加容量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤弹性设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;酒店PMS系统可能会出现故障或有性能问题，但不会影响系统的性能或正常运行时间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以按需部署微服务，想部署多少都可以。部署的越多，容错性以及对变化的管理手段就越多。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤独立技术栈（Tech Stack Independence）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;你可以有多个技术栈，每项服务也配备了最适合的技术栈。你的顾客资料一般会在存储关系型数据库内，而相关请求却会放在非关系型数据库（NoSQL）中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;此外，没有一个特定的技术栈是长期适用的，毕竟，技术栈有很多个。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤添加、变更、消除特性及重构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;微服务是一些很小的服务，通常只有几百行的代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于这些代码的内聚性使得它们简单易懂，也就是它们每个服务都运行在自己的进程中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;其中一个的变化对其他的服务不会有直接的影响。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;删除整个微服务系统也比较容易，基本没有什么风险。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤部署&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;酒店想要提供额外的服务，但必须在系统正常、无故障的情况下才能实现，比如正常将客户登记的信息以及更新状态的请求发送给PMS系统。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;回滚也比较容易。假使过程中出现错误，相对于在整体单一式的数据库中回滚整个系统，通过自己的数据库回滚恢复到上一个微服务的操作也比较简单。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;另外，对整体单一式的应用来说，部署下一个版本非常痛苦，即便只是新增一个单一特性，也需要对整个程序进行部署，而且一次性部署所有事宜也是很具有风险性的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：如果只是与一个PMS集成，微服务就是大材小用了，但如果在大规模集成的情况下，微服务架构的好处就体现出来了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;传统方法：整体单一式的应用程序&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，整体单一式的应用对开发新产品和开展新业务来说是比较有利的，因为它的操作简单。但在此期间，你仍需了解目前所在的领域，以及将它们集成整合到一起的方法。运用整体单一式的应用在开发和部署时更简单，也更方便模拟预订服务，以及在客户资料的微服务版块内实现顾客资料模块的设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过随着公司的发展，整体规模也会迅速增长；因此随着规模的增大，系统的运行也越来越困难，需要增加新的特性和代码。而随着系统内容的增加，系统逐渐会不受控制，从而不能很好地执行运维。由于整体单一式的应用通常既不内聚也不耦合，变更系统时需要更多的回归测试，以确保新特性不会破坏系统的其他部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，由于代码之间互相依赖，会增加故障诊断与调试的难度。在更新服务时，需要对共享的基础设施代码执行修改，如果中间出现bug就会出问题。而且，这么大的代码库也很难在短时间内让新晋的开发人员熟练掌握。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，它对部署也有影响：应用程序越大，启动的时间就越长。也许新增更多的服务，并对其进行复制十分简单，但要记得我们只有一个单一的数据库。而且不仅如此，系统的一些部分可能会需要使用更多内存，而其他的部分则需要更多的CPU。因此，如果无法分别权衡各个组件的需求时该怎么办？没错，只能增加更多的新服务器——但这种做法的成本极高。所以，一旦有一定规模的公司，都会想要将系统分解成微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;架构概况&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在我们要来解释一下采用微服务架构所带来的长期性效益。不过，我们先来了解下微服务架构的设计细节。最重要的一点就是分离：集成系统应互相独立。举例来说，你的核心系统独立于X物业内运行的物业管理系统，同时也独立于Y物业运行的系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要想实现这种分离需要在核心系统和所有物业管理集成系统之间使用一个连接器，即中间件。中间件由两个方面组成：消息队列和background worker。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可用于实现服务的例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消息队列：RabbitMQ，IronMQ等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;后台worker：IronWorker，AWS Lambda等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息队列为系统间提供异步通信。发送者系统（你的系统）发布了一个消息到队列中，之后消息就会留在那里，直到稍后有订阅过队列的后台worker来处理。之后，后台worker会负责处理这则消息（解析内容）并利用PMS API进行管理集成，同时将数据保存到了中间件的数据库内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：后台worker可以是像AWS Lambda的云服务，也可以是Java或Windows服务器内部开发的程序。下面我们将会详细对其介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;值得注意的是，消息队列遵循的是先进先出的原则（FIFO），因此处理队列中所有的消息都会按照它们输入的顺序。假设你有多个队列，发布到X队列的信息稍后会比Y队列中的信息优先处理。这一点在设计的时候需要考虑进去。不过，如果酒店的系统是PMS，那就不需要担心这些，因为它会在云或本地的系统中运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这项服务不仅仅是一个CRUD包装器，因为它还控制着与预订相关的所有生命周期事件。如果需要指定预订一间房、新增一位陪同客人或登记入住的话，就需要发送一个恰当的请求给同一worker。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在我们根据Martin的描述来逐条分析一下微服务主要的几个特征，以及我们的架构又是如何实现这些特征的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;围绕业务能力的组织&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在如何与PMS集成过程中，每个worker都负责实现一块逻辑。我们可以在一家资产产业的同一个PMS实例中接入多个worker，在另一家酒店添加与同一个PMS（相同运营商）相连的更多worker，也可以在其他产业中添加与其它PMS相连的其它worker。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，假如我们需要修改与某些API互动的方式，只需单独对其中一个worker进行新版部署即可，完全不会影响到其它worker。我们可以让一个worker处理预订事宜，让另一个处理顾客资料档案事宜；可以使用Linux的crontab来安排一些后台worker，按照指定日程来循环执行任务；令其它一些worker持续运行，并在收到消息时立即处理。其它后台worker也可以唤醒核心系统的API，以便插入或更新其自PMS那里收集到的新消息（比如从PMS获取或读取数据，将之载入核心系统）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Sam Newman所著的《构建微服务》一书中，他指出“基于较为小型的数据库工作的较小型团队生产率更高”——通过微服务就能实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不仅生产率的问题，将团队或个人从一个微服务切换到另一个（共享同一个数据库）也是可以的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而且由于长时间在同一个项目中工作的团队或个人可能会产生局限性，这种做法还能鼓励创新：让团队在产品与项目上互换，可能会造就数以千计的新点子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤自动化部署&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微服务的部署需要以自动化形式实现，原因为何？首先是因为微服务数量太多，如果手动部署，不但很容易出错，也很浪费时间。具体情况要取决于所拥有的微服务数量，而且每个服务必须分别、独立的发布。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意，这里说的是部署微服务的新版本，并不涉及新的worker实例——worker已经在运行中了，但需要部署新的代码版本。举例说明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;假设要集成1000家产业，其中有500家使用运营商1所提供的PMS（即PMS_1），另有500家使用运营商2所使用的PMS（即PMS_2）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;除了运营商之外，由于背景十分相似，这里各个PMS实例中的worker数量很可能也是差不多的，除非我们想要添加更多相同类型的worker。为了简单起见，我们假设每个PMS实例中有5个worker，一个负责预订，一个负责顾客档案等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于PMS_1的API与PMS_2的API不同，与PMS_1集成的预订服务其中的代码就和与PMS_2集成的预订服务代码不同。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在这1000家产业中，有5000个worker，其中：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: circle;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PMS_1有2500个，500个负责预订工作，500个负责顾客资料工作，500个X worker，500个Y worker，500个Z worker，与PMS_1集成，每家产业各一；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PMS_2有2500个，500个负责预订工作，500个负责顾客资料工作，500个X worker，500个Y worker，500个Z worker，与PMS_2集成，每家产业各一。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;假设我们对与PMS_1集成的预订服务做了代码修改，通过测试后准备发布。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;假设源代码数据库只有一个，各个微服务也使用了持续集成工具，现在需要将代码部署到500个worker上，也就是与PMS_1集成的500个预订服务worker。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，使用微服务的目的之一就是为了敏捷灵活，因此我们需要自动化。这就是持续集成与持续交付（CI与CD）大显身手的时候了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CI即需要开发人员一天数次将代码集成到共享数据库的开发实践，提交就会触发build，如果build失败就会向所有人发送警告。其中的关键在于，及早发现提交出现的问题（也即是代码的问题）。如果build成功，就会部署到应用服务器上，并触发持续交付（CD）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CD即确保上面build成功的内容可以快速部署到生产环境中的实践，首先将应用部署到与生产环境特性相同的staging环境中，再点击“部署”按钮即可将应用部署到生产环境中。这里最棒的是：由于只需点击一个按钮，这样实现时就无需打断软件工程师的工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可用于执行CI/CD的服务样例包括：Atlassian Bamboo、TeamCity、Jenkins等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，不要将持续交付与持续部署相混淆，本文不会深入讨论这个问题，不过PuppetLabs有一篇文章是讨论持续交付与持续部署的不同点的，值得一读。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还要注意：微服务在部署时比整体单一式的应用更安全，因此实现自动化也更容易。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤端点的智能化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后台运行的worker封装了与PMS集成的逻辑，如果需要变更逻辑，或者变更PMS的API，我们只需修改一个地方即可——但不是在主系统中（主系统需要与下游API的变更隔离）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，各个PMS都有自己的API，因此要将与各个API通讯的逻辑与核心系统相隔离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤语言与数据的分散控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个微服务都有自己的技术堆栈，因此我们可以运用技术异质性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，需要改善特定组件的性能时，选择能够实现需要性能的技术堆栈即可。新的服务并不依赖于旧的技术定义，而且会在适合的时候使用新的语言或技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;各个worker可使用不同的技术构建：worker 1使用Java语言，MySQL数据库，负责处理顾客资料；worker 2使用C#语言，NoSQL数据库，负责处理顾客留言。要记得：它们是彼此独立的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们需要考虑集成的问题，比如在实践中如何互相集成。你是否有计划要部署RESTful API来返回JSON，或者与XML对话的SOAP API呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在我们来深入探讨一下中间件的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤中间件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中间件将系统和我们与之交互的多个资产管理系统隔离开来，由消息队列与后台worker组成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中间件不应当保存状态：各个端点的系统，比如你的系统与PMS系统负责保存酒店、顾客资料、预订信息等相关的状态，而中间件只负责创建两个系统之间的映射。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因在于：我们不希望引入一个保存状态新组件，从而造成一致性问题。而且同一个事务存储在三个不同的系统——即酒店资产管理系统，中间件系统和核心应用中，如果出现bug就会很难集成。在这样的情况下，哪个系统保存的是真实的预订状态呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中间件必须为我们统一核心系统与PMS系统的内容提供方法，因此如果在核心系统中有新需求创建，但出于某些原因，比如离线、软件有bug、网络问题等，没能存入PMS，中间件就应当向用户发出警告，并提供重集成的方法。中间件必须为每条信息在队列中的位置，还有每个后台worker的状态提供清晰的可视化效果。让用户了解某条消息出错以及出错原因，并提供重试机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在中间件数据库的顶层要有一个缓存层，以便能更为迅速地访问常用对象，比如城市代码、信用卡类型等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;使用微服务所带来的挑战&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在构建任何软件时都会有挑战，特别是大规模的集成系统时。在《构建微服务》一书中，Newman提醒我们“在大规模实现中，出错在所难免”，在部署微服务时也是如此。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们要接受这一现实——无论硬盘、网络等等都会出错，处理多个独立服务的错误也非常困难。分布式与异步架构在部署和debug时都很难实现，我们需要查看分布在多个实例中的日志，查看分布式事务来了解为什么会出现奇怪的状态。如果在同步流程中出错，进行上一个状态的回退是很困难的。由于经常会并行工作，找到出错点也是很困难的，而且由于可能有竞争条件介入，也会难以管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;确保微服务大规模实现中的一致性是另一个挑战。想象一下，一个服务管理顾客资料，另一个管理预订服务。如果有新顾客第一次预订你的酒店，预订微服务会创建新的预订记录，而顾客资料微服务需要创建新的顾客资料。如果顾客资料出现bug，没能成功创建新的顾客资料呢？如果没能正确执行管理，最终就只剩一个不与任何顾客资料相关联的单独预订记录。在大规模的情况下，这种情况很难追踪与管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;异步分布式架构可能会导致其它问题：假设系统向事务队列发出特定类型的请求，导致worker崩溃，而且又添加了从同一个队列拉取消息的多个worker，来加快处理速度。第一个worker从队列拉取消息，然后挂掉了，请求超时锁定，原本的消息被丢回队列。然后第二个worker要从队列中拉取同一个消息，结果一样，也挂掉了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一个挑战在于，我们必须持续监控数百个服务的重新部署，从而导致有需求促发专门的DevOps资源或团队来管理如此数量巨大的服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当有许多远程调用的时候，由于是通过网络连接的，还需要考虑整体的系统性能。我们都知道，网络是不可靠的，可能会导致数据包延迟或丢包等等。此外，各个系统之间的消息也并非实时传达的：向消息发布一条消息之后，隔一阵子才能得到处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，通过微服务有效地实现版本控制也是很困难的，最终需要改变服务的接口。如何进行管理呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在各个架构中的处理方法都有所权衡，不但微服务中存在挑战，每种方法也存在挑战。管理多个PMS的大规模集成时，使用微服务的好处要远大于付出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;考虑到大规模部署的经济效益：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在微服务的部署中，一些比较成本如下：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在大规模部署中，100个不同的PMS集成可能需要100个服务器。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在单一整体式的方法中，这些服务器要持续运行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;而在微服务中，可以按需唤醒微服务，并在不需要的时候关闭。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用类似AWS Lambda或者IronMQ之类的云服务时，AWS所提供的按需供应系统可以让我们按照需求来应用，从而更有效地控制自己的花费。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长期使用的情况下，微服务更加划算，而且能够更接近实际地管理开销，减少浪费。从未有过如此节省的架构方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面要怎么做？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;告别整体单一式架构&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经常会有一个问题：“我的应用已经应用了整体单一式架构，是否需要从头重构，以便部署微服务架构呢？”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;答案是：不需要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以一点点地改动，最终告别单一整体式架构。这应当是一个递增式的方案，我们可以从中更深入地了解核心功能，以及它与其它核心功能的互动方式。对服务应有的状态，以及与其它服务的通讯方式要建立起认知，这是很关键的。采用“边学边干”的方式，逐步定义系统的哪个部分应当使用微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着系统规模的扩大，微服务数量增长，这一方法会让你更灵活、更有效也成本更低地扩展系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt; How To Build Your Property Management System Integration Using Microservices 作者： Rafael Neves，本文作者Rafael Neves是Alice公司的首席企业架构师。Alice公司是一家总部位于纽约的酒店领域技术创业公司，虽然隶属于资产管理领域，但也是微服务方面的入门优秀范例。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;译者：&lt;/strong&gt; 孙薇&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;责编：&lt;/strong&gt; 钱曙光，关注架构和算法领域，寻求报道或者投稿请发邮件qianshg@csdn.net，另有「CSDN 高级架构师群」，内有诸多知名互联网公司的大牛架构师，欢迎架构师加微信qshuguang2008申请入群，备注姓名+公司+职位。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016年9月22日-23日，SDCC 2016大数据技术&amp;amp;架构实战峰会将在杭州举行，两场峰会大牛讲师来自阿里、京东、苏宁、唯品会、美团点评、游族、饿了么、有赞、Echo等知名互联网公司，共同探讨海量数据下的应用监控系统建设、异常检测的算法和实现、大数据基础架构实践、敏捷型数据平台的构建及应用、音频分析的机器学习算法应用，以及高可用/高并发/高性能系统架构设计、电商架构、分布式架构等话题与技术。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9月4日24点前仍处于最低六折优惠票价阶段，单场峰会（含餐）门票只需499元，5人以上团购或者购买两场峰会通票更有特惠，限时折扣，预购从速。（阅读原文获取票务详情）。&lt;/span&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 07 Sep 2016 17:08:35 +0800</pubDate>
    </item>
    <item>
      <title>企业在数据库领域面临的五大挑战</title>
      <link>http://www.iwgc.cn/link/2580900</link>
      <description>&lt;p&gt;&lt;span&gt;大数据时代，数据已成为公司最有价值的资产之一，因此，设计、实现和维护好数据库，对公司是至关重要的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据IDC数据显示，在2015年到2017年间，数据库市场已由400亿美元增长到500亿美元。然而，企业只有高效管理这些数据，才能在新的应用和云计算领域立于不败之地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面让我们一起来看看当今企业在数据库领域面临的五大挑战：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;配置数据资产&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接近80%的开发者和IT专业人员认为，数据库资产配置是当前的主要瓶颈之一，开发人员需要更灵活地加快这一过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺乏专业的DBAs&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据的急速增长也对DBAs产生了更多的需求，市场上普遍缺乏熟练专业的DBAs，这也就意味着因为企业缺乏人才而导致一些项目被搁置，从而没有足够的IT基础设施来推动创新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;影响性能的因素有很多，比如数据库配置和数据库扩张。此外，糟糕的数据库设计、编码错误和额外的数据和用户都可能影响和放缓整体的数据库性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库扩展&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着公司业务发展，IT基础设施建设也应跟上来，并提前规划好未来的增长。而不是临时或随便添加多种版本的SQL服务器，这样，数据分配在不同的数据库服务器里，着实难以维护。这种缺乏战略规划的行为也很容易造成数据库性能低下，并且带来很大的安全风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;快速增长的数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务转换和数据的爆炸式增长使得企业很难高效地管理它们的数据存储和管理需求。虽然大部分企业的IT基础设施仍停留在以往建设水平，但也有许多企业正在迁移到云或者混合云上，把云作为当前数据管理的一种解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据的爆炸式增长，使得企业需要采取更具有战略性的方法来管理和维护好数据库。这对企业的快速壮大和扩张也至关重要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjXuhHf9WCBWMNzicyLwZNBVib5CHFBqtzgfgFXvxlzFaVO9qkvvNwbwdJBmgWnUH4IHdWOiczXEnqibow/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;</description>
      <pubDate>Tue, 06 Sep 2016 17:25:01 +0800</pubDate>
    </item>
    <item>
      <title>【大牛说】SDCC 2016架构实战峰会（杭州站）之大牛谈（第四季）</title>
      <link>http://www.iwgc.cn/link/2580901</link>
      <description>&lt;p&gt;&lt;span&gt;想必有很多人已然知道，2016年9月22日-23日，由CSDN重磅打造的大数据核心技术与实战峰会、互联网应用架构实战峰会将在杭州举行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一方面你可以从官网了解到最新的信息，也可以看下这篇关于届时出场的讲师名单和详细议题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;SDCC 2016大数据&amp;amp;架构峰会（杭州站）讲师和议题最全公开&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时，我们也做了讲师专访，抢先查看：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;专访京东杨超：出色的架构师应具备的素质&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;专访游族姚仁捷：机器学习和异常检测相结合，提升运维能力&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了让杭州的技术圈深入了解SDCC，我们在每次文章里提到我们的理念和原则，再在这里重申下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;秉承干货实料（案例）的内容原则。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而SDCC具有深厚的历史背景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;始建于2007年的SDCC，已经成功举办七届，历届技术讲师超过550位，参会人数超过7500人，成为技术圈口碑卓越的技术会议品牌。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在此前，我们SDCC已经进驻了上海、深圳和成都等地，广受好评，给与会者留下了深刻的印象，如果你需要看到当时的会务资料，在这里一并奉上：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;SDCC 2016系列全回顾：数据库&amp;amp;大数据&amp;amp;运维&amp;amp;架构（附50+PPT下载）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我们认为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;每一年都有诸多大大小小的技术峰会，你如何给一场会议评价是一件比较难的事情，每个人看到的都是不同的，而为了让用户有更多的甄选信息，特邀请一些演讲嘉宾、行业的参会大牛分享他们的看法，或许可以管中窥豹看到一些不同。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，这也是继《大牛说》栏目第一季、第二季和第三季结束后的第四季，以下为部分精华：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;span&gt;胡峰 京东成都研究院智能通讯部资深架构师&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8月份刚刚结束的SDCC成都站，机缘巧合受邀参加，这也是SDCC第一次在成都举办，但火爆程度超出预期。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给我的感觉是SDCC邀请的主讲嘉宾都是真正在一线积累颇为深厚的技术精英，一路听来，干货满满，启发良多，受益颇丰。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这里有可能会给你带来启发和指引，也有可能给你机会去和前方的同行深度交流，面对SDCC你还在犹豫什么？&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，希望SDCC越办越好，成为技术人在黑暗中摸索航行的灯塔。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;胡志广 百度资深工程师&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很荣幸作为讲师参加SDCC大会，参会的有国内各大互联网和牛人分享内容，让大家收益颇深，从架构、知识、视野都可以得到提升，并且促进国内各大城市的技术交流，希望这样的会议能更多一些能让国内互联网人都受益。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;李林锋 华为PaaS平台架构师&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8月份有幸参加了SDCC成都站峰会，结识了很多国内一线的专家和技术大牛，讲师们带来的分享都是最前沿、最实用的干货，通过跟各位专家交流，我自己也受益匪浅。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SDCC杭州站峰会聚焦在大数据核心技术以及互联网架构，邀请的都是实战经验丰富的一线技术专家，相信一定会给大家奉献一场精彩的技术盛宴。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;陶文质 腾讯互娱事业部后台高级工程师&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你对架构与运维设计充满了浓厚的兴趣，如果你对技术界的各种奇思妙想充满了深切的渴望，如果你对业界大牛交流沟通的机会充满了长久的期盼，那么SDCC将是不二之选。而且在CSDN这样具有深厚底蕴和影响力平台的支持下，你将会获得在技术海洋恣意畅游的完美体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;魏自立 360高级工程师、资深顾问&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SDCC是CSDN重磅打造的互联网技术实战峰会，重点突出干货和成功案例的技术分享，给整个技术圈的所有同仁带来全新的技术视野和思路。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我有幸作为讲师参与了2016成都SDCC峰会，结识了一帮业内技术大牛，在聆听大牛们的技术分享中，我受益颇丰。非常感谢CSDN举办这种干货满满的技术盛宴，祝SDCC峰会越办越好，立足中国走向世界。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;高磊 华为分布式与并行实验室 架构师&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我是这样看待SDCC会议的，这是迄今为止我所参加的最好论坛之一，它以激动、详实、并以客观来愉悦着我们的思想。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不论怎样，现在这个时代就是要求我们不断的吸纳新的思维，而这样的分享形式也正是满足了我们的需要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;span&gt;梁阳鹤 乐视boss平台技术部资深软件开发架构师&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8月有幸参加了SDCC成都站大会。会场上各位讲师都分享了各自的干货，很多知识点都能在项目中直接使用，很接地气。SDCC成都站还有现场微信群，大家可以和讲师们在微信群中讨论各种问题，结交各种大牛，感谢CSDN与SDCC为我们提供的技术交流平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;欧阳辰 小米研发架构师&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SDCC大会是互联网架构师的盛会，有幸参加今年成都站的SDCC，感受到大会几个特点：干货充实厚重、实践见微知著、思考望其项背、选题海纳百川、组织井井有条。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;架构作为大会的主线，把很多行业发展、组织架构、技术选型、算法机器学习、大数据分析等都关联起来，给参与者一个360度的视角。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这也是一个“三人行必有我师”的大会，参会者有机会认识很多志同道合的朋友，向行业专家指教，其中不少互动环节也是非常有趣、有乐、有红包的。这是一个不虚此行的大会。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;号外，SDCC 2016架构技术峰会杭州站，8折限时优惠中，预购从速，&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;猛戳官网和票务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjXuhHf9WCBWMNzicyLwZNBVib5CHFBqtzgfgFXvxlzFaVO9qkvvNwbwdJBmgWnUH4IHdWOiczXEnqibow/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;</description>
      <pubDate>Tue, 06 Sep 2016 17:25:01 +0800</pubDate>
    </item>
    <item>
      <title>聚光灯下的熊猫TV技术架构演进</title>
      <link>http://www.iwgc.cn/link/2580902</link>
      <description>&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz/ianq03UUWGmKfVhVHzJZuMhn7fo97kMcmRa28I7kmDbiaEbcDtARKbIxRUEFFA3BdqZrsPBS0ickkBOAicNVIMy2AA/0?wx_fmt=gif"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;2016 年 9 月 23-24 日，由 CSDN 和创新工场联合主办的“&lt;span&gt;MDCC 2016 移动开发者大会• 中国&lt;/span&gt;”（Mobile Developer Conference China）将在北京•国家会议中心召开，来自iOS、Android、跨平台开发、产品设计、VR开发、移动直播、人工智能、物联网、硬件开发、信息无障碍10个领域的技术专家将分享他们在各自行业的真知灼见。大会门票8折优惠中，五人以上团购更有特惠，限量供应（&lt;span&gt;票务详情链接&lt;/span&gt;，&lt;span&gt;8折优惠，欲购从速！&lt;/span&gt;）&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;作者简介：&lt;/strong&gt;沈冠璞，熊猫TV高级应用开发工程师，近7年后端开发经验，曾任职新浪微博、360等互联网公司，负责短链接、微博Card对象、网游页游平台业务。对高并发海量数据业务设计有丰富经验；经历熊猫TV从0到1 海量PV和存储的快速扩张发展场景，有大中型互联网网站高可用设计架构经验。&lt;strong&gt;在MDCC 2016上，沈冠璞将结合自身经验，解析在热门时段大主播高峰值情景下优化礼物系统技巧，带来题为《百万弹幕下的直播礼物系统》的分享。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;本文为&lt;span&gt;《程序员》&lt;/span&gt;原创文章，未经允许不得转载，更多精彩文章请订阅&lt;span&gt;2016年《程序员》&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;2015年开始的百播大战，熊猫TV是其中比较特别的一员。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;说熊猫TV是含着金钥匙出生的公子哥不为过。还未上线，就频频曝光，科技号，微博稿，站上风口浪尖。内测期间更是有不少淘宝店高价倒卖邀请码，光内测时用户注册数量就达几十万，火爆程度可见一斑。笔者作为写下熊猫TV第二行代码的Coder，见证了熊猫TV成立以来的风风雨雨。直播技术坑不少，本文简单揭秘熊猫TV这一年的技术架构演进，分析各个阶段面临的主要问题和应对方案，给大家做直播系统提供一定的参考。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;熊猫架构 0.1－ 来不及了，老司机快上车&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这个阶段最大的目标就是按预期时间上线。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/eL7YiacLdzwoVicxZ0PCe00V9DL8ysicTo1icc5ILdshJY0qWHcVpv0I2NQKnIR4KoeA4d9juB9ibper8LvjuIIe2kg/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;span&gt;图1 项目规划时间表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;组团队不表，10人左右的Web团队，从接需求，到上线，我们用了不到三个月。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这个阶段面临的最大难题：两个月就内测！&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;怎么办？找老战友刷刷刷！花钱买买买！作为一群经验丰富的老司机，我们用买零件翻新车的方法。网站内测公测阶段，需要满足用户登录注册、关注主播、看视频、发弹幕、加房管、领任务、送免费竹子等核心功能，采用了复用模块＋主业务全新开发的策略。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;复用模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;复用模块得益于团队的前360技术背景，根据直播秀场类项目上的技术积累，利用PHP框架Pylon、发版工具Rigger，在老战友的帮助下，重新搭建了一套QBus消息组件，长连接系统，改进的Redis、MongoDB和MySQL集群，视频云服务，敏感词服务，搜索服务，这个项目才有了强大的基础支撑，才有可能在两个月时间就上线。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;视频模块——从新搭建视频云，RTMP推流拉流，接入三家CDN作为互备。这其中需要自己实现统一调用接口和服务，方便切换CDN： 推流地址、拉流地址、转码规定、开播断流回调、一键断流、连接数查询、流截图、直播时长查询。基本上每个接口都很重要！例如一键断流万一失效，则可能面临停业整顿风险；人数不准，主播挂人气刷榜，则可能导致不公平竞争而影响平台的体验与口碑。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分布式基本组件：复用Syslog-ng日志收集系统、Kafka消息队列QBus、MySQL主从库、Redis主从库、MongoDB、SSDB大容量存储。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;长连消息：单机百万长连，支持千万用户同时在线，性能够用，保证聊天弹幕稳定性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;图床：很重要的一环，房间截图，用户头像。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CMS系统：配置各种推荐位，直播间的CDN调度。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;主业务开发&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;虽然是个新项目，我们并未做一个一篮子应用，把所有接口放在一个项目，而是按功能模块分好项目，每人负责一个，对主站panda.tv项目提供内网API，部署方便互不影响，开发效率也比较高。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;Flash播放器：ActionScript开发、视频播放、弹幕展现。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;主站pandaren：页面展现，各个子服务的串联整合；Daemon Worker负责截图更新。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户体系ruc：用户注册登录、用户信息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;房间服务vill：包括房间信息、房间列表、更新房间人气。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关系服务uprofile：包括订阅关系、观看历史、主播申请、内测邀请码 。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数值服务count：竹子赠送、主播身高、用户经验。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;消息服务homer：用于房间划分，长连Session ID和熊猫TV房间用户ID的转换。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;权限系统buffon：房间管理、房管、黑名单。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;任务服务bee：新手任务、观看定时奖励。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;主播直播时长bloodstone：主播固定工资需要按每月直播时长计算。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;架构哲学和设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;熊猫TV架构第一原则是高可用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;网络：需要应对国内复杂的网络环境，使用内网光纤互联的多IDC来覆盖多运营商。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;资源：DB和缓存都是集群化，配置Virtual IP方便切换。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;隔离性：不同业务不同机器，防止雪崩效应；核心和非核心业务隔离，流量扛不住情况保重点业务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;降级：从Nginx和API层设置接口开关、Cache开关、DB开关，出问题一键切换。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;超时控制：主站每个依赖业务设置5秒超时，并有报警和错误日志。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;异步：用户不关心实时结果的大写入量业务使用异步方式更新，提高核心服务性能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;监控：服务器错误设置log监控、接口监控报警，随时处理线上异常。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;架构目标（SLA）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;根据以往新项目经验，预估支撑1000TPS ，百万日活用户，单房间10万左右在线弹幕；平均响应时间在100ms，99.9%在1s内；千万级别数据量；99.9%的可用性（全年宕机在9小时以下）。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;架构选型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;四层负载均衡：LVS，目前基本是业界标配，如果使用云服务的话可以用厂商提供的负载均衡，如阿里云SLB和亚马逊ELB等，这种第三方依赖都需要严格引流压测确认DB层、缓存层、Web层是否&amp;nbsp;&lt;/p&gt;&lt;p&gt;有坑；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;Web层：Nginx＋PHP-FPM，开发迅速，适合团队技术现状，但需要针对服务器，做一定的调优配置。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存层：Redis主从库、SSDB大容量存储，会在各个业务块儿使用，增加系统性能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;存储层：MySQL主从库存储重要业务数据，属性变化不大。MongoDB数据库存储字段不固定变更较多的数值明细记录。SSDB存储观看记录关注等列表较长，且性能要求较高的数据。分表分库上考虑用户注册量和主播播放频率，用户中心、主播播放时长采用了按用户ID Sharding和 按年Sharding两种策略。业务初期暂时没有分库需求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;消息队列：实现业务解耦，使用当前较流行的Kafka队列。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;设计实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;机器配置采用6核16G的虚拟机。服务部署单独的XEN虚拟机集群，互不影响，进行多机房互备，机房间光纤专线内网互通。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/eL7YiacLdzwoVicxZ0PCe00V9DL8ysicTo1IrorBSFmjJibd2eshY0boXIrSFqDpB0GLSmrkLm9cnTwouEmoPvvXKQ/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;span&gt;图2 整体架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;120台虚拟机分给十多个业务，主站用了40+，三个IDC——电信联通移动同时使用，流量大的主机房在电信，其他两个机房部署Redis、MySQL从库，写都在电信。预估的注册在线人数百万级，QPS万级。接口使用PHP-FPM对外服务，单机性能平均500QPS＋，内测邀请制，内测一个月期间十几万人涌入，解决了一些小Bug，然后大家颇有信心迎接公测。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;熊猫架构1.0——一只穿云箭，千军万马来相见&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这个阶段属于填坑，最主要目标是网站稳定可用。虽然每个服务都有多机房灾备，微服务化也做了较好隔离，但0.1不到一个月便宣告夭折，我们低估了熊猫TV的明星效应，低估了黑色产业链的薅羊毛能力。公测一开始，熊猫就炸了（水友术语，指网站不可用）。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;重点问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style="list-style-type: decimal;"&gt;&lt;li&gt;&lt;p&gt;网站首页和房间页不可用，无法进房间看视频；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;已经在直播间的用户直播卡、弹幕卡、弹幕发不出去。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;分析：网站因注册和用户信息、首页、房间页访问量过大导致FPM进程跑满，接口和模版渲染耦合，本身占的调用时长就会过多，服务间断性不可用，Redis缓存首页推荐位和用户信息只需几百MB，但连接数过多，内存占用到10G＋，导致Redis响应缓慢不可用，垃圾号疯狂注册，第一天便破百万，用户中心出现服务异常，缓存命中率低，进而雪崩。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;聊天弹幕爆发，时段非常集中，每日晚8点到凌晨2点为网站高峰时段，如图3所示。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/eL7YiacLdzwoVicxZ0PCe00V9DL8ysicTo1Dc9RwmRrCaroU7CYKfthTHc5rwThm0pVwvBiaWbopymj4VSXndDGXIg/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;span&gt;图3 某个Redis端口QPS情况&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这些也是直播网站会一直面临的核心稳定性问题，针对这些问题，大架构框架没有变动，加班加点，两周时间就上线了新一版架构优化。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高性能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;主站重点接口Lua化：消息限制发送频率，并改造为Lua接口，十倍提速，避免占用主站PHP-FPM资源；赠送竹子也改造为Lua接口；用户中心取用户信息也改为Lua接口，直接从缓存读。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;用户ID发号器改造，不依赖MySQL自增ID，提高并发性能。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高可用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;首页和房间页静态化，Worker机抓取生成模版，分钟级别更新，然后rsync到各个服务器，Nginx直接读HTML文件生成首页、房间页，其他个人动态信息都走Ajax请求，保证不会出现白屏情况。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;重点Redis增加到10＋ Slave，Slave间树型同步，叶子节点从库从上级从库同步，避免一主多从传输数据延迟。从库的增加也避免主库网络负荷和连接数过多，导致响应延迟过大，服务不可用。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;核心业务增加部署服务器，应对集中峰值访问。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;其他问题解决和功能完善&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;安全性上：所有80接口做XSS校验，CSRF token防范，对接口做几十道安全检测，防止被拖库，防止Cookie被盗用；反垃圾反盗号反外挂：含敏感词聊天信息过滤，垃圾IP封禁；注册和任务都增加图片验证码，识别机器刷用户刷竹子；房间人气值采用复杂策略，用算法综合判断确认合理性，防刷防挂；主播审核更加严格，身份证银行卡姓名等信息都要求录入，可以追究责任到真人，甚至有视频验证，严防色情内容。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;功能上：建立游戏娱乐户外等分类模块，运营自助增加分类；部署并自行运维第三方搜索服务，支持主播昵称、标题、房间号等维度搜索，过滤直播状态、主播地区、封禁状态等条件；礼物系统抽奖投票等系统上线，增加主播收益渠道，增加互动。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;优化效果：全年未出现过白页、首页不可访问情况，支撑千万级PV，百万级日活，单房间最高达到百万级在线，视频流量近TB级；接口平均响应时间20ms左右，99.9%在1s内；各个系统数据存储量破千万，MongoDB、SSDB等大容量库很好地支持了业务。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;熊猫架构 2.0 － 新视界，大不同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;到2.0阶段，初期的刷脸靠战友帮搭建基础服务和买第三方服务，已不能精细化、定制化地支撑业务快速发展，而此时人员配置也开始完善，熊猫TV开始了全新的2.0自主研发阶段。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;本阶段也属于稳步发展阶段， 最主要的目标是视频流畅清晰、弹幕互动效果稳定。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;视频优化&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;接入决策上，接入更多家CDN，并对CDN稳定性做指标考核和严要求：根据卡顿率、延迟时间、首屏时间、声音视频同步率等指标，结合运营经验，创建了一套立体化多维度的CDN-SLA体系，决定给予流量多少，主播级别，主播数量。这样也增加CDN的危机感，更好服务用户。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;视频流调度互备上，如图4所示。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/eL7YiacLdzwoVicxZ0PCe00V9DL8ysicTo1y3jclJzVrDO3dISgmiceI4YK0QfXYqP7RnxCXTMm9dTQYyJRicicUcqBQ/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;span&gt;图4 视频流调度互备上&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;主播推流区分默认配置和管理员配置，推向对他而言网络状况最好的CDN，CDN自身节点实现各地的复制，CDN之间实现推流互备，一个CDN挂掉，不影响使用，用户根据PC或手机端区分，从对应配置的CDN拉流看视频，从而实现最佳观看效果，Web端用户也可切换备用线路，当默认CDN出现问题，则选择从其他家CDN进行拉流。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这样就保证观看的流畅和视频的整体高可用。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;全新开发长连接系统riven来提供弹幕服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/eL7YiacLdzwoVicxZ0PCe00V9DL8ysicTo1UicicTaDeTa0S8NbFvPvguELeA30ptnA3GTRbNY09OUr3icUfOMSktgCA/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;span&gt;图5 riven 整体流程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;建立连接：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;通过房间ID获取网关IP；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;根据网关IP建立长连接；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更新网关上房间ID和长连接的对应关系。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;下发消息：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;同步消息；&amp;nbsp;&lt;/p&gt;&lt;p&gt;生成消息机房对其他机房进行同步；&lt;/p&gt;&lt;p&gt;同步消息的机房不在进行同步行为；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;根据房间ID获取房间所在的网关地址列表；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;向网关列表下发消息投递通知；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;网关查询本地房间对应的所有连接，并进行消息投递。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;使用Golang＋Redis全新开发，对消息级别、消息发送和消息内容做了一定优化。级别上区分多种Level消息，在高峰期、网卡被打满极端情况下，丢掉部分不重要消息；消息发送进行打包方式发送，一个房间的消息一次批量推送几十条，减少TCP交互；消息内容去掉无用字段，减少长度，例如礼物消息一条减少了168字节，假设高峰期一个房间十万人在线，一条礼物消息能节16MB，大主播房间按1000个礼物一小时算，能节省16GB流量，非常可观，所以一定要注意消息内容的压缩和缩减。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;整体架构上的改变：一年以来用户量爆炸式增长，达到日活用户近千万，PV上亿，同时直播主播近万间，流量峰值TB级别。技术人员也扩充了4倍，随着王校长驱动开发、尹素婉驱动开发（尹素婉是韩国第一女主播）、PDD驱动开发（PDD是前职业选手，著名LOL主播，弹幕量大，观众百万）等模式的驱动开发，熊猫快速步入2.0时代，技术架构也有了更稳固的改进，新的PHS（Panda High-Perfomace Service熊猫高性能服务体系）设计思路是增加架构层次，明确微服务边界，基础组件从外部依赖到内部自研，架构层次宏观层面分为端、接入层、平台服务化、中间层、基础层五个层次。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/eL7YiacLdzwoVicxZ0PCe00V9DL8ysicTo1kQKmNIYBl6CQUcUEvy0BCrJGQiavVhicGnPURfRN098Tr7jTVCtSpqQA/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;span&gt;图6 架构层次&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;端&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;包括Web页、iOS、Android、各种Pad端、网吧弹窗合作、电视盒子合作App、游戏主机合作App，从各个渠道扩展业务。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;接入层&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;从大而统一的panda.tv分流出mall.panda.tv、roll.panda.tv、pay.panda.tv、open.panda.tv等，保证各个接入业务互相隔离。接入层stars.panda.tv、pandagirls.panda.tv尝试使用NodeJS提供API，前端完全自行研发，提高效率，性能也比使用我们的Pylon-PHP框架提高了6倍左右，可以满足当前流量请求。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;平台服务化&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;架构体系没有太大的变动，主要采用Golang技术栈做了整体升级。流量突发时PHP-FPM子进程新增缓慢，多进程模型切换代价较大，不能较好服务高峰请求，缓存和DB连接池复用困难，我们重点业务从PHP迁移到Golang；部署上，依赖Nginx+LVS探活实现不停机热部署；Gobase基础库，实现了一套特定业务场景Concurrent Map库；实现了配置读取模块；对MongoDB Client进行了封装，便于CRUD方式使用和对象映射；Redis连接池和CRUD操作封装，业务不需要协议命令细节，而是正常Get(key)、Set(key)即可；数据访问层结合配置服务封装分片与路由来支撑容量水平扩展；封装Log、HTTP请求和HTTP Param解析等基础类。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;通过对Golang半年的使用，我们建立了自己的一套技术开发体系：Gvt创建项目和管理依赖，Ansible管理服务器和分发部署，Postman进行文档编排和代码测试， Teamcity实现持续集成。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;业务上，CDN调度项目TrafficCoop，高性能，灵活配置Web端和移动端CDN信息；API-Proxy项目 ，原生Golang Router，使用OAuth 2.0，提供对外网关，中转内部服务；礼物系统全面使用Golang+Redis+MongoDB保证稳定性和高峰处理。新业务原则需要快速开发，性能要求较低的业务使用PHP，性能要求高的业务用Golang、NodeJS。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;用户中心则持续演进：支持FaceBook等账号接入；电话语音验证码防外挂，异地IP重新登录机制防盗，个人身份指纹识别，做到彻底防盗号。另外为提高接口安全性，解决DNS劫持等问题对服务HTTPS化，各业务根据需要跟Ops申请HTTPS证书或SAN（多域名）证书。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;中间层改进&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;视频效果优化：接入更多CDN厂商，进行评测对比，及时反馈问题，督促其合理设置缓存值，实现视频播放流畅化。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Flash调整弹幕展现策略：实现既能有满屏感，又不会因同屏弹幕过多卡住浏览器，达到观看和互动的平衡。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;文本反作弊：机器学习训练房间弹幕内容，模型上对广告、色情、敏感词、黑白名单等进行打分评定。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;增加图片墙鉴黄服务：30秒刷新房间截图，接入多家鉴黄API，合理评分，快速发现直播内容异常。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;图床自建：图片存储从Cassandra迁移到公有云对象存储，节省运维成本，直接使用第三方CDN，加速图片访问。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;基础层&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Kafka队列自建：基础组专人开发维护，更快更好解决问题；竹子经验计数、用户关系等从SSDB迁移到Redis Cluster，保证性能无瓶颈，数据量暴增无压力。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Spark Streaming平台搭建：弹幕内容分析与舆情，CDN质量实时监控，用户行为实时感知。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;另外一个比较大的架构变动是业务机房迁移。实现了DB迁移，公有云互备。二十多人演练数十次，按照两页的迁移清单，所有业务重新部署，DB重新导入，停机维护一整夜，所有服务从原有机房一次性成功迁移到两个公有云上。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;熊猫TV架构改进思路是应对峰值流量高度集中的直播需求，总结几条经验：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;不能依赖单个CDN。可自建，可用第三方，但中国网络环境太复杂，必须高度重视容灾。海外推拉流也需要十分关注。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;弹幕消息一定要做策略优化。广播蝴蝶效应明显，峰值可能将机房整体带宽打满。区分弹幕优先级，做好降级预案。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提高金钱敏感度。直播网站由于有很清晰的变现模式，要严防褥羊毛，严防色情内容，火速响应监管，支付礼物交互一定是高可用、严监控。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;N个大主播 ＝ 半个网站峰值。必须考虑某些特殊主播的火爆人气，做好视频弹幕房间信息上的峰值应对。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;熊猫TV因快速上线和爆炸式增长，从严重依赖外部服务，到自主自建核心业务，弯路走了不少，也对直播技术有了更深的理解，积累了丰富的经验，技术团队也从20人左右快速扩展到百人团队，为熊猫TV在百家直播平台中挺立飞奔奠定了技术基础。未来我们会在以下方面继续努力：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;自助式运营处理：帮助运营自助处理问题，直接和CDN对接，帮助技术人员从简单重复问题处理中脱身。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;反作弊：基于大数据处理体系的用户画像、设备画像、IP画像、内容画像，多维度构建反垃圾反盗号功能 。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;长连优化：支撑千万用户在线的高并发实时弹幕和聊天。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;礼物商城：优化计数对账，幂等处理整个支付到特效抽奖、弹幕消息、消费记录、统计等流程。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Golang、NodeJS服务化：替代性能较差需要各种优化的PHP，服务端接口全面Golang化，前端也在合适的场景使用NodeJS提高服务性能。此外需针对KV存储做value压缩，节省流量，提高接口速度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据挖掘和机器学习：渠道分析、用户分析等便于产品和高层决策，甚至开发出机器人主播互动。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;推荐：在综艺化娱乐化多元化的内容基础上，个性化推荐用户感兴趣的直播内容。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;搜索：自建搜索，从用户维度、聊天维度更好服务用户。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;日志收集分析：高性能日志方案探索，更快更迅速发现业务问题，分析流量变化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;广告系统：友好娱乐化的广告展现，精准推送，严禁的计费系统。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支付：国际化支持，多种银行卡信用卡接入，多种货币支持。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NewSQL：引入TiDB等新SQL技术到某些业务，替换Redis、MongoDB、MySQL，更方便友好地进行技术开发。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;直播面临的核心问题是网站稳定可用、视频流畅清晰、弹幕互动效果稳定。直播技术看似简单，一家视频云可以帮助创业公司一两个月就构建出一个直播App，但其中的运营难点、技术难点、流量带宽问题都需要谨慎处理，希望本文能帮助直播行业技术人员跳过一些坑，架构设计时作为技术参考。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;关于移动开发新技术，更多精彩尽在MDCC 2016，详情请查看大会官网：&lt;span&gt;MDCC 2016移动开发者大会&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/eL7YiacLdzwoVicxZ0PCe00V9DL8ysicTo1NicSwUnLPoiake54eCFLJmFEznRTicxXCszjLG6hnQNuNqyqic4RqSia33w/0?wx_fmt=jpeg"/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;点击下方&lt;/span&gt;&lt;span&gt;“&lt;span&gt;阅读原文&lt;/span&gt;”&lt;/span&gt;&lt;span&gt;火速报名MDCC！&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;↓↓↓&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;</description>
      <pubDate>Tue, 06 Sep 2016 17:25:01 +0800</pubDate>
    </item>
    <item>
      <title>浏览器存储及使用</title>
      <link>http://www.iwgc.cn/link/2531840</link>
      <description>&lt;p&gt;&lt;span&gt;伴随着WEB的发展，浏览器的存储方式及技术不断的发生更改，从刚开始的Cookie，到localStorage，sessionStorage，再到IndexedDB，再到现在的Web SQL，作为一名合格的前端开发，当然需要对这些技术了如指掌并熟练掌握，本文将比较全面的介绍常见的浏览器存储以及其使用。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsqrj7ia5m00FiaXJshkecaPqeGGJzytz0dO8CXl6utlia0B5FEecRQwSsQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section style="
text-align: left;
overflow: hidden;"&gt;&lt;section&gt;&lt;p&gt;1&lt;/p&gt;&lt;/section&gt;&lt;section style="
vertical-align: top;
padding-bottom: 500px;
margin-bottom: -500px;
width: 84%;
box-sizing: border-box;
background-color: #dedede;
display: inline-block;"&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;Cookie&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cookie是一个用户通过浏览器浏览网站产出的信息的票根，Cookies通常被用来标示一个网站用户的浏览经历，它可能包含这个用户的个人偏好或访问这个网站的一些输入信息。用户可以自己随意操作他们浏览器中的Cookie。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cookies可以通过服务端使用Set-Cookie Http header来设置和修改，当然也可以使用javascript的document.cookie去操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;浏览器兼容性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcs9wDhGRV7jocgiaQ8iaOSLo0Bglu6ceeHiblEbny5PlRlfBocicR8lKk5aA/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细请参考：&lt;span&gt;http://caniuse.com/#search=cookie&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;在浏览器中操作如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;//读取网站下所有的cookie信息，获取的结果是一个以分号;作为分割的一个字符串&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var allCookies = document.cookie;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//例如：在百度首页，获取的如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// "BAIDUID=B32F2BF6BCB66D5559E199F5B1908F4C:FG=1; PSTM=1444711125; BIDUPSID=9DE77BD4B191F421CA54DB11C954067A; ispeed_lsm=0; MCITY=-289%3A; BDSFRCVID=hWtsJeC62Ag8XZc4Nvqo2MixJD2vkWoTH6aoB7vKuwGS_LREoJS6EG0PtvlQpYD-KiV2ogKK0eOTHvvP; H_BDCLCKID_SF=JbADoDD-JCvbfP0kKtr_MJQH-UnLq-vUbT7Z0l8KtqjJbMnL-TOF5R_eD4c0hUTRtjcW-b7mWIQHDp_65xRh5U-9BPvN04RZLbc4KKJxbPQSVtJXQKcvMq5XhUJiB5O-Ban7LtQxfJOKHICRe5-ajxK; BD_CK_SAM=1; locale=zh; BD_HOME=0; H_PS_PSSID=1455_18241_18559_17000_15227_11651; BD_UPN=123253"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//往原来的已经存在的cookie中加入新的cookie&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;document.cookie ="test=yui";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//当然也可以在后面加上可选择的选项键值对，例如domain，以及其他path，expires&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;document.cookie="test=yui;domain=.baidu.com"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//删除cookie，就是让这个cookie值得expires过，就是设置这个expires为0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;document.cookie="test=yui;domain=.baidu.com;expires=0");&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;需要注意的地方：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1) 通过上面的代码，可以看到document.cookie是个可访问的属性，但是它有内置的setter和getter的function，而不是一个简单的字符串数据，你的get和set都会调用这些原生内置的函数；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2) Cookie支持跨域，可以通过在根域名设置cookie，共享多个子域名的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;Cookie的Chrome浏览器实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cookie解析：&lt;span&gt;https://code.google.com/p/chromium/codesearch#chromium/src/net/cookies/parsed_cookie.h&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section style="
text-align: left;
overflow: hidden;"&gt;&lt;section&gt;&lt;p&gt;2&lt;/p&gt;&lt;/section&gt;&lt;section style="
vertical-align: top;
padding-bottom: 500px;
margin-bottom: -500px;
width: 84%;
box-sizing: border-box;
background-color: #dedede;
display: inline-block;"&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;Web Storage&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Web Storage有两种机制，分别为sessionStorage和localStorage。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage是一种半持久化的本地存储（会话级别的存储），而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两个对象，对外的方法主要有：setItem、getItem，以键值对的形式存储和读取，key按照索引获取当前存储的key值，找不到时返回null，length属性代表当前存储的key value对数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;浏览器兼容性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsfhAicBQ7ZRYMZg5E5cJbVC5AH5tEPib4W0GgeLeO3oWLn7c3k0liaia7kQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细请参考：&lt;span&gt;http://caniuse.com/#search=localstorage&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;代码示例（&lt;span&gt;以localStorage为例&lt;/span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;var username = 'helloworld';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var storageUsername;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var randomArr = [Math.random()，Math.random()，Math.random()，Math.random()];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var storageRandomArr;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//storage username，key值区分大小写，存入的内容为这个变量调用toString方法的结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage.setItem("username"，username);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//获取&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;storageUserName &amp;nbsp;= localstorage.getItem("username");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//"helloworld"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//删除&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage.removeItem("username");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;storageUserName &amp;nbsp;= &amp;nbsp;localstorage.getItem("username");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// null&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//存储对象时，可以先调用JSON.stringify方法，然后取出的时候再调用JSON.parse方法获取结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage.setItem("randomarr"，JSON.stringify(randomArrr));&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;storageRandomArr = JSON.parse(localStorage.getItem("randomarr"));&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Object.prototype.toString.call(storageRandomArr);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// "object Array"&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section style="
text-align: left;
overflow: hidden;"&gt;&lt;section&gt;&lt;p&gt;3&lt;/p&gt;&lt;/section&gt;&lt;section style="
vertical-align: top;
padding-bottom: 500px;
margin-bottom: -500px;
width: 84%;
box-sizing: border-box;
background-color: #dedede;
display: inline-block;"&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;IndexDB&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IndexedDB是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的API。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IndexedDB分别为同步和异步访问提供了单独的API，异步API方法调用完后会立即返回，而不会阻塞调用线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要异步访问数据库，要调用Window对象IndexedDB属性的open()方法。该方法返回一个IDBRequest对象(IDBOpenDBRequest)；异步操作通过在IDBRequest对象上触发事件来和调用程序进行通信。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IndexDb是NoSQL数据库，是一种支持事务的浏览器数据库，基本操作就是，打开数据库，增删改查各种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;浏览器兼容性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsvUJfEKLzFAOmm3rGuAw1wibJQteEx4JSOm38d38JLnwxClkN39iaDVrg/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细请参考：&lt;span&gt;http://caniuse.com/#search=IndexDB&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;代码示例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1) 打开数据库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;//处理浏览器兼容性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//如果该数据库MyDatabase不存在，则会被创建；如果已经存在，则被打开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open("MyDatabase");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//打开数据库失败的回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; console.log("failure");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//代开数据成功的回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onsuccess = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; console.log("success");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2) 初始化数据库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;var dbName = "MyDatabase";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var dbVersion = 2;//整数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// open函数接受的第二个参数，代表数据的版本，当打开的版本号比当前的版本号大时，会触发onupgradeneeded这个回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open(dbName，dbVersion);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var studentsData = [{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"001"，name:"xiaoming"，email:0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}，{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"002"，name:"xiaoxiang"，email:1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var tableName = 'students';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //错误处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onupgradeneeded = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var db = event.target.result;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //创建表，以id字段作为主键来确保唯一，使用keyPath表示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var objectStore = db.createObjectStore(tableName， { keyPath: "id" });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //给表添加索引&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore.createIndex("name"，"name"，{unique:false});//非unique索引&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore.createIndex("email"，"email"，{unique:true});//email字段作为unique索引&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; for(var i in studentsData){&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //插入数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; objectStore.add(studentsData[i]);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; console.log("---init db success---");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3) 使用事务添加、删除数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;transaction()方法接受两个参数并返回一个事务对象。第一个参数是事务希望跨越的对象存储空间的列表，即数据库中的表名称。如果你希望事务能够跨越所有的对象存储空间你可以传入一个空数组。第二个参数如果你没有为第二个参数指定任何内容，默认只读。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcsB6xPTUvRTb1oqaiaOIvTUUE7tKJtXvojRHsw51seYjMDtC2glBonZOA/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;插入学生003，004，005&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;var dbName = "MyDatabase";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open(dbName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var addData = [{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"003"，name:"xiaofang1"，email:"3@qq.com"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}，{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"004"，name:"xiaofang2"，email:"4@qq.com"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}，{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; id:"005"，name:"xiaofang3"，email:"5@qq.com"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var tableName = 'students';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//打开数据库失败的回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; console.log("open indexDb database failure");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//代开数据成功的回调&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onsuccess = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var db = event.target.result;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var transaction = db.transaction([tableName]，'readwrite');&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var objectStore;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var i;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //事务主要有三个回调，error，abort，success&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.onerror = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //处理错误&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(event);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.onbort = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //事务中断处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.oncomplete = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("添加数据成功");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore &amp;nbsp;= transaction.objectStore(tableName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; for(i &amp;nbsp;in addData){&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var request = objectStore.add(addData[i]);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; request.onsuccess = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("add one success");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;删除001学生&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;var dbName = "MyDatabase";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open(dbName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var db;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var tableName = 'students';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onsuccess &amp;nbsp;= function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var objectStore;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var transaction;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; db = &amp;nbsp;event.target.result;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction= db.transaction([tableName]，'readwrite');&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.onerror = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //处理错误&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("error when delete 001 "+ event.target.errorCode);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.onbort = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //事务中断处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; transaction.oncomplete = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("删除学生001成功");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore = transaction.objectStore(tableName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore.delete("001");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4) 使用索引查找数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要调用IDBObjectStore示例对象的index方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;var dbName = "MyDatabase";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var request = window.indexedDB.open(dbName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var db;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var tableName = 'students';&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onerror = function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;request.onsuccess &amp;nbsp;= function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var index;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; var objectStore;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; db = &amp;nbsp;event.target.result;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; objectStore = db.transaction([tableName]).objectStore(tableName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //根据索引字段email朝找3@qq.com的学生&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; index = objectStore.index("email").get("3@qq.com");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; index.onsuccess = function(event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(event.target.result);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; };&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; index.onerror = function (event) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("error when find &amp;nbsp;by index "+ event.target.errorCode);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;indexDb还有游标查找功能，限于篇幅，就不展开介绍了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section style="
text-align: left;
overflow: hidden;"&gt;&lt;section&gt;&lt;p&gt;4&lt;/p&gt;&lt;/section&gt;&lt;section style="
vertical-align: top;
padding-bottom: 500px;
margin-bottom: -500px;
width: 84%;
box-sizing: border-box;
background-color: #dedede;
display: inline-block;"&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;WebSql&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Web SQL Database API实际上未包含在HTML 5规范之中，它是一个独立的规范，它引入了一套使用SQL操作客户端数据库的API，这些API有同步的，也有异步的，一般情况下，都会使用异步API。它的核心方法有三个：openDatabase，transaction和executeSql。这些API已经被广泛的实现在了不同的浏览器里，尤其是手机端浏览器。虽然W3C官方在2011年11月声明已经不再维护Web SQL Database规范，但由于其广泛的实现程度，了解这些API对Web开发还是非常有必要的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;浏览器兼容性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuia03icwYIJazLYF0uGs5vPcscz5ymq3AY17tibvg7pM2oWhzpn8c0vsuOdUic5w3gY6HuuycGag2FibdQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详情请参考：&lt;span&gt;http://caniuse.com/#search=WebSql&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;代码示例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;var db;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;var info = {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; dbName :"MyDataBase"，//数据库名称&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; dbVersion:"0.1"，//版本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; dbDisplayName:"测试数据库"，//显示名称&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; dbEstimatedSize:10*1024*1024 //数据库大小，单位字节&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db = window.openDatabase(info.dbName，info.dbVersion，info.dbDisplayName，info.dbEstimatedSize);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//初始化students表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db.transaction(function (trans) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; //执行Sql，如果students表不存在，则创建改表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; trans.executeSql("create table if not exists students(id unique，name text null，email text null)"，[]， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("init success");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("error happen");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//插入数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db.transaction(function (trans) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; trans.executeSql("insert into students(name，email) values(?，?)"，['xiaoming'，'1@qq.com']， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("insert ok 1");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(arguments);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; trans.executeSql("insert into students(name，email) values(?，?)"，['xiaohong'，'2@qq.com']，function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("insert ok 2");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }， function () {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(arguments);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//删除数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db.transaction(function (trans) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;trans.executeSql("delete from students where name = ? "，['xiaohong']， function (trans，result) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.log("delete success");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;}， function (trans，message) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.log("error happen");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;});&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//查询数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;db.transaction(function (trans) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; trans.executeSql("select * from students"，[]， function (trans，result) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("总共查询到 "+result.rows.length+" 条数据");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }， function (trans，message) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log("error happen");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;});&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section style="
text-align: left;
overflow: hidden;"&gt;&lt;section&gt;&lt;p&gt;5&lt;/p&gt;&lt;/section&gt;&lt;section style="
vertical-align: top;
padding-bottom: 500px;
margin-bottom: -500px;
width: 84%;
box-sizing: border-box;
background-color: #dedede;
display: inline-block;"&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;其他&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;Application Cache&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Application Cache翻译成中文为应用程序缓存，是html5中为实现离线浏览所提供的API。结合Manifest文件使用，使用编程方式，更新浏览器缓存内容。主要调用update与swapCache去更新浏览缓存，目前该技术已经被最新的规范所废弃，转而使用了Service Workers。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;Service Workers&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个service worker是一段运行在浏览器后台进程里的脚本，它独立于当前页面，提供了一些不需要与web页面交互的功能，即那种在网页背后悄悄执行的能力。在将来，基于它可以实现消息推送，静默更新等服务，但是目前它首先要具备的功能是拦截和处理网络请求，包括可编程的响应缓存管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section style="
text-align: left;
overflow: hidden;"&gt;&lt;section&gt;&lt;p&gt;6&lt;/p&gt;&lt;/section&gt;&lt;section style="
vertical-align: top;
padding-bottom: 500px;
margin-bottom: -500px;
width: 84%;
box-sizing: border-box;
background-color: #dedede;
display: inline-block;"&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;小结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前Cookie的兼容性最好，使用的最广泛，但有被滥用的趋势。Web Storage兼容比较好，除了老板的IE 6，7不支持外，其他主流浏览器都已经支持了，使用起来也方便简单，适合存储键值对数据。WebSql由于未在HTML5规范中，前景堪忧，适当了解下。IndexDb目前来看，兼容性不太好，但是前景很好，目前由w3c在推广，相信在以后应该有个大爆发(个人看法)。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Application Cache目前已经被废弃，Service Workers目前属于起步阶段，感觉离实用还需要时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;参考链接&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;caniuse：http://caniuse.com/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Cookie：https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;谷歌开发者中心文档：https://developer.chrome.com/devtools/docs/resource-panel#inspecting-page-resources&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Mozilia 开发者中心：https://developer.mozilla.org/en-US/docs/Web&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ServiceWorkers：http://www.html5rocks.com/en/tutorials/service-worker/introduction/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section label="Copyright © 2015 playhudong All Rights Reserved." style="
margin:1em auto;
border-style: none;" donone="shifuMouseDownCard(&amp;#39;shifu_c_005&amp;#39;)"&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;声明：&lt;/strong&gt;本文为CSDN原创投稿文章，未经许可，禁止任何形式的转载。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;作者：&lt;/strong&gt;叶文兵，MaxLeap UX组开发人员，负责公司主要项目前端开发工作，逐渐往Node.js全栈方向发展。本科毕业于安徽师范大学，入坑前端开发近3年。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;责编：&lt;/strong&gt;钱曙光，关注架构和算法领域，寻求报道或者投稿请发邮件qianshg@csdn.net，另有「CSDN 高级架构师群」，内有诸多知名互联网公司的大牛架构师，欢迎架构师加微信qshuguang2008申请入群，备注姓名+公司+职位。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016年9月22日-23日，SDCC 2016大数据技术&amp;amp;架构实战峰会将在杭州举行，两场峰会大牛讲师来自阿里、京东、苏宁、唯品会、美团点评、游族、饿了么、有赞、Echo等知名互联网公司，共同探讨海量数据下的应用监控系统建设、异常检测的算法和实现、大数据基础架构实践、敏捷型数据平台的构建及应用、音频分析的机器学习算法应用，以及高可用/高并发/高性能系统架构设计、电商架构、分布式架构等话题与技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9月4日24点前仍处于最低六折优惠票价阶段，单场峰会（含餐）门票只需499元，5人以上团购或者购买两场峰会通票更有特惠，限时折扣，预购从速。（票务详情http://bss.csdn.net/m/topic/sdcc_invite/hangzhou#goupiaoxinxi）。&lt;/span&gt;&lt;/p&gt;</description>
      <pubDate>Fri, 02 Sep 2016 17:34:37 +0800</pubDate>
    </item>
  </channel>
</rss>
